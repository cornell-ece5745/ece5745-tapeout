//-------------------------------------------------------------------------
// grp_17_SPI_TapeOutBlockRTL_32bits_5entries.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL SystemVerilog translation pass.

// PyMTL VerilogPlaceholder SPI_TapeOutBlockVRTL Definition
// Full name: SPI_TapeOutBlockVRTL__nbits_32__num_entries_5
// At /home/zx83/ece5745/submissions/project-group17/sim/tapeout/SPI_TapeOutBlockRTL.py

//***********************************************************
// Pickled source file of placeholder SPI_TapeOutBlockVRTL__nbits_32__num_entries_5
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder SPI_TapeOutBlockVRTL
//-----------------------------------------------------------

`ifndef SPI_TAPEOUTBLOCKVRTL
`define SPI_TAPEOUTBLOCKVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component SPI_TapeOutBlockVRTL__nbits_32__num_entries_5.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component SPI_TapeOutBlockVRTL__nbits_32__num_entries_5

`line 1 "tapeout/SPI_TapeOutBlockVRTL.v" 0
//===============================================================================================
// SPI_TapeOutBlockVRTL
//===============================================================================================
// A composition module combining the SPI stack (SPI Minion, SPI Minion Adapter, and Loopthrough)
// that connects to the individual project group's block module. This was used for the 
// efabless tapeout in Spring 2022.
//
// Author : Jack Brzozowski
//   Date : May 9th, 2022

`line 1 "SPI_v3/components/SPIstackVRTL.v" 0
// ==========================================================================
// SPIstackVRTL.py
// ==========================================================================
// 
// Author: Jack Brzozowski
//     May 7, 2022

`line 1 "SPI_v3/components/LoopThroughVRTL.v" 0
// ==========================================================================
// LoopThroughVRTL.py
// ==========================================================================
// This module is meant to either loopback data to the the upstream module, 
// or pass data to the downstream module, depending on the select bit. 
// If sel = 1, no data is passed to the downstream block, it is simply 
// looped to the upstream.
// If sel = 0, this module essentially connects the upstream to the 
// downstream blocks.

// Author: Dilan Lakhani, Updated by Jack Brzozowski
//     February 25, 2022

module SPI_v3_components_LoopThroughVRTL 
#(
    parameter nbits = 32 // the size of the val/rdy msg
)(
    input logic clk,
    input logic reset,
    input logic sel,

    // upstream Minion Ifc
    input  logic             upstream_req_val, 
    input  logic [nbits-1:0] upstream_req_msg, 
    output logic             upstream_req_rdy, 

    output logic             upstream_resp_val,
    output logic [nbits-1:0] upstream_resp_msg,
    input  logic             upstream_resp_rdy,

    // downstream Master Ifc
    output logic             downstream_req_val, 
    output logic [nbits-1:0] downstream_req_msg, 
    input  logic             downstream_req_rdy, 

    input  logic             downstream_resp_val,
    input  logic [nbits-1:0] downstream_resp_msg,
    output logic             downstream_resp_rdy
);

    assign upstream_resp_val= (sel) ? upstream_req_val : downstream_resp_val;
    assign upstream_resp_msg= (sel) ? upstream_req_msg : downstream_resp_msg;

    assign downstream_req_val= (sel) ? 0 : upstream_req_val;
    assign downstream_req_msg= upstream_req_msg;

    assign upstream_req_rdy= (sel) ? upstream_resp_rdy : downstream_req_rdy;

    assign downstream_resp_rdy= (sel) ? 0 : upstream_resp_rdy;

endmodule
`line 9 "SPI_v3/components/SPIstackVRTL.v" 0
`line 1 "SPI_v3/components/SPIMinionAdapterCompositeVRTL.v" 0
//-------------------------------------------------------------------------
// SPIMinionAdapterCompositeVRTL.v
//-------------------------------------------------------------------------
`line 1 "SPI_v3/components/SPIMinionVRTL.v" 0
//==========================================================================
//SPIMinionVRTL.v
//==========================================================================

`line 1 "SPI_v3/components/ShiftReg.v" 0
/*
==========================================================================
ShiftReg.v
==========================================================================
N-bit shift register.
*/

module ShiftReg
#(
    parameter nbits = 8
)
(
  input  logic             clk,
  input  logic             in_,
  input  logic [nbits-1:0] load_data,
  input  logic             load_en,
  output logic [nbits-1:0] out,
  input  logic             reset,
  input  logic             shift_en 
);
  
  always_ff @(posedge clk) 
  begin 
    if ( reset ) begin
      out <= { nbits{1'b0}};
    end
    else if ( load_en ) begin
      out <= load_data;
    end
    else if ( ( ~load_en ) & shift_en ) begin
      out <= { out[nbits-2:0], in_ };
    end
  end

endmodule
`line 6 "SPI_v3/components/SPIMinionVRTL.v" 0
`line 1 "SPI_v3/components/Synchronizer.v" 0
/*
==========================================================================
Synchronizer.v
==========================================================================
 - RTL code for the Synchronizer module.
 - It samples the input signal using the device clock and also detects
     positive and negative edges.
 - Reference: https://www.fpga4fun.com/SPI2.html
*/

module Synchronizer 
#(
    parameter reset_value = 1'b0
)(
  input  logic clk ,
  input  logic in_,
  output logic negedge_,
  output logic out,
  output logic posedge_,
  input  logic reset 
);

  logic [2:0] shreg;
  
  always_comb begin
    negedge_ = shreg[2] & ( ~shreg[1] );
    posedge_ = ( ~shreg[2] ) & shreg[1];
  end
  
  always_ff @(posedge clk) begin
    if ( reset ) begin
      shreg <= { 3{reset_value} };
    end
    else
      shreg <= { shreg[1:0], in_ };
  end

  assign out = shreg[1];

endmodule
`line 7 "SPI_v3/components/SPIMinionVRTL.v" 0

module SPI_v3_components_SPIMinionVRTL
#(
  parameter nbits = 8
)
(
  input  logic             clk,
  input  logic             cs,
  output logic             miso,
  input  logic             mosi,
  input  logic             reset,
  input  logic             sclk,
  output logic             pull_en,
  input  logic [nbits-1:0] pull_msg,
  output logic             push_en,
  output logic [nbits-1:0] push_msg,  
  output logic             parity
);
  //-------------------------------------------------------------
  // Component cs_sync
  //-------------------------------------------------------------

  logic cs_sync_clk;
  logic cs_sync_in_;
  logic cs_sync_negedge_;
  logic cs_sync_out;
  logic cs_sync_posedge_;
  logic cs_sync_reset;

  Synchronizer #(1'b1) cs_sync
  (
    .clk( cs_sync_clk ),
    .in_( cs_sync_in_ ),
    .negedge_( cs_sync_negedge_ ),
    .out( cs_sync_out ),
    .posedge_( cs_sync_posedge_ ),
    .reset( cs_sync_reset )
  );

  //-------------------------------------------------------------
  // Component mosi_sync
  //-------------------------------------------------------------

  logic mosi_sync_clk;
  logic mosi_sync_in_;
  logic mosi_sync_negedge_;
  logic mosi_sync_out;
  logic mosi_sync_posedge_;
  logic mosi_sync_reset;

  Synchronizer #(1'b0) mosi_sync
  (
    .clk( mosi_sync_clk ),
    .in_( mosi_sync_in_ ),
    .negedge_( mosi_sync_negedge_ ),
    .out( mosi_sync_out ),
    .posedge_( mosi_sync_posedge_ ),
    .reset( mosi_sync_reset )
  );

  //-------------------------------------------------------------
  // Component sclk_sync
  //-------------------------------------------------------------

  logic sclk_sync_clk;
  logic sclk_sync_in_;
  logic sclk_sync_negedge_;
  logic sclk_sync_out;
  logic sclk_sync_posedge_;
  logic sclk_sync_reset;

  Synchronizer #(1'b0) sclk_sync
  (
    .clk( sclk_sync_clk ),
    .in_( sclk_sync_in_ ),
    .negedge_( sclk_sync_negedge_ ),
    .out( sclk_sync_out ),
    .posedge_( sclk_sync_posedge_ ),
    .reset( sclk_sync_reset )
  );

  //-------------------------------------------------------------
  // Component shreg_in
  //-------------------------------------------------------------

  logic             shreg_in_clk;
  logic             shreg_in_in_;
  logic [nbits-1:0] shreg_in_load_data;
  logic             shreg_in_load_en;
  logic [nbits-1:0] shreg_in_out;
  logic             shreg_in_reset;
  logic             shreg_in_shift_en;

  ShiftReg #( nbits ) shreg_in
  (
    .clk( shreg_in_clk ),
    .in_( shreg_in_in_ ),
    .load_data( shreg_in_load_data ),
    .load_en( shreg_in_load_en ),
    .out( shreg_in_out ),
    .reset( shreg_in_reset ),
    .shift_en( shreg_in_shift_en )
  );

  //-------------------------------------------------------------
  // Component shreg_out
  //-------------------------------------------------------------

  logic             shreg_out_clk;
  logic             shreg_out_in_;
  logic [nbits-1:0] shreg_out_load_data;
  logic             shreg_out_load_en;
  logic [nbits-1:0] shreg_out_out;
  logic             shreg_out_reset;
  logic             shreg_out_shift_en;

  ShiftReg #( nbits ) shreg_out
  (
    .clk( shreg_out_clk ),
    .in_( shreg_out_in_ ),
    .load_data( shreg_out_load_data ),
    .load_en( shreg_out_load_en ),
    .out( shreg_out_out ),
    .reset( shreg_out_reset ),
    .shift_en( shreg_out_shift_en )
  );
  
  always_comb begin
    shreg_in_shift_en = ( ~cs_sync_out ) & sclk_sync_posedge_;
    shreg_out_shift_en = ( ~cs_sync_out ) & sclk_sync_negedge_;
  end

  assign cs_sync_clk         = clk;
  assign cs_sync_reset       = reset;
  assign cs_sync_in_         = cs;
  assign sclk_sync_clk       = clk;
  assign sclk_sync_reset     = reset;
  assign sclk_sync_in_       = sclk;
  assign mosi_sync_clk       = clk;
  assign mosi_sync_reset     = reset;
  assign mosi_sync_in_       = mosi;
  assign shreg_in_clk        = clk;
  assign shreg_in_reset      = reset;
  assign shreg_in_in_        = mosi_sync_out;
  assign shreg_in_load_en    = 1'b0;
  assign shreg_in_load_data  = {nbits{1'b0}};
  assign shreg_out_clk       = clk;
  assign shreg_out_reset     = reset;
  assign shreg_out_in_       = 1'b0;
  assign shreg_out_load_en   = pull_en;
  assign shreg_out_load_data = pull_msg;
  assign miso                = shreg_out_out[nbits-1];
  assign pull_en             = cs_sync_negedge_;
  assign push_en             = cs_sync_posedge_;
  assign push_msg            = shreg_in_out;
  assign parity              = (^push_msg[nbits-3:0]) & push_en;

endmodule

`line 5 "SPI_v3/components/SPIMinionAdapterCompositeVRTL.v" 0
`line 1 "SPI_v3/components/SPIMinionAdapterVRTL.v" 0
//-------------------------------------------------------------------------
// SPIMinionAdapterVRTL.v
//-------------------------------------------------------------------------
`line 1 "vc/queues.v" 0
//========================================================================
// Verilog Components: Queues
//========================================================================

`ifndef VC_QUEUES_V
`define VC_QUEUES_V

`line 1 "vc/regs.v" 0
//========================================================================
// Verilog Components: Registers
//========================================================================

// Note that we place the register output earlier in the port list since
// this is one place we might actually want to use positional port
// binding like this:
//
//  logic [p_nbits-1:0] result_B;
//  vc_Reg#(p_nbits) result_AB( clk, result_B, result_A );

`ifndef VC_REGS_V
`define VC_REGS_V

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop
//------------------------------------------------------------------------

module vc_Reg
#(
  parameter p_nbits = 1
)(
  input  logic               clk, // Clock input
  output logic [p_nbits-1:0] q,   // Data output
  input  logic [p_nbits-1:0] d    // Data input
);

  always_ff @( posedge clk )
    q <= d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with reset
//------------------------------------------------------------------------

module vc_ResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d      // Data input
);

  always_ff @( posedge clk )
    q <= reset ? p_reset_value : d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable
//------------------------------------------------------------------------

module vc_EnReg
#(
  parameter p_nbits = 1
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( en )
      q <= d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable and reset
//------------------------------------------------------------------------

module vc_EnResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( reset || en )
      q <= reset ? p_reset_value : d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

`endif /* VC_REGS_V */


`line 9 "vc/queues.v" 0
`line 1 "vc/muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux (DOES NOT WORK WITH EFABLESS FLOW)
//------------------------------------------------------------------------

`endif /* VC_MUXES_V */


`line 10 "vc/queues.v" 0
`line 1 "vc/regfiles.v" 0
//========================================================================
// Verilog Components: Register Files
//========================================================================

`ifndef VC_REGFILES_V
`define VC_REGFILES_V

//------------------------------------------------------------------------
// 1r1w register file
//------------------------------------------------------------------------

module vc_Regfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 1r1w register file with reset
//------------------------------------------------------------------------

module vc_ResetRegfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,
  parameter p_reset_value = 0,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge. We have to use a generate statement to
  // allow us to include the reset logic for each individual register.

  genvar i;
  generate
    for ( i = 0; i < p_num_entries; i = i+1 )
    begin : wport
      always_ff @( posedge clk )
        if ( reset )
          rfile[i] <= p_reset_value;
        else if ( write_en && (i[c_addr_nbits-1:0] == write_addr) )
          rfile[i] <= write_data;
    end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r1w register file
//------------------------------------------------------------------------

module vc_Regfile_2r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                   clk,
  input  logic                   reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r2w register file
//------------------------------------------------------------------------

module vc_Regfile_2r2w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en0,
  input  logic [c_addr_nbits-1:0] write_addr0,
  input  logic [p_data_nbits-1:0] write_data0,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en1,
  input  logic [c_addr_nbits-1:0] write_addr1,
  input  logic [p_data_nbits-1:0] write_data1
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk ) begin

    if ( write_en0 )
      rfile[write_addr0] <= write_data0;

    if ( write_en1 )
      rfile[write_addr1] <= write_data1;

  end

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en0 );
      `VC_ASSERT_NOT_X( write_en1 );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en0 ) begin
        `VC_ASSERT_NOT_X( write_addr0 );
        `VC_ASSERT( write_addr0 < p_num_entries );
      end

      if ( write_en1 ) begin
        `VC_ASSERT_NOT_X( write_addr1 );
        `VC_ASSERT( write_addr1 < p_num_entries );
      end

      // It is invalid to use the same write address for both write ports

      if ( write_en0 && write_en1 ) begin
        `VC_ASSERT( write_addr0 != write_addr1 );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// Register file specialized for r0 == 0
//------------------------------------------------------------------------

module vc_Regfile_2r1w_zero
(
  input  logic        clk,
  input  logic        reset,

  input  logic  [4:0] rd_addr0,
  output logic [31:0] rd_data0,

  input  logic  [4:0] rd_addr1,
  output logic [31:0] rd_data1,

  input  logic        wr_en,
  input  logic  [4:0] wr_addr,
  input  logic [31:0] wr_data
);

  // these wires are to be hooked up to the actual register file read
  // ports

  logic [31:0] rf_read_data0;
  logic [31:0] rf_read_data1;

  vc_Regfile_2r1w
  #(
    .p_data_nbits  (32),
    .p_num_entries (32)
  )
  rfile
  (
    .clk         (clk),
    .reset       (reset),
    .read_addr0  (rd_addr0),
    .read_data0  (rf_read_data0),
    .read_addr1  (rd_addr1),
    .read_data1  (rf_read_data1),
    .write_en    (wr_en),
    .write_addr  (wr_addr),
    .write_data  (wr_data)
  );

  // we pick 0 value when either read address is 0
  assign rd_data0 = ( rd_addr0 == 5'd0 ) ? 32'd0 : rf_read_data0;
  assign rd_data1 = ( rd_addr1 == 5'd0 ) ? 32'd0 : rf_read_data1;

endmodule

`endif /* VC_REGFILES_V */


`line 11 "vc/queues.v" 0
`line 1 "vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */


`line 12 "vc/queues.v" 0

//------------------------------------------------------------------------
// Defines
//------------------------------------------------------------------------

`define VC_QUEUE_NORMAL   4'b0000
`define VC_QUEUE_PIPE     4'b0001
`define VC_QUEUE_BYPASS   4'b0010

//------------------------------------------------------------------------
// Single-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a single-elment queue. It is designed to
// be attached to a storage element with a write enable. Additionally, it
// includes the ability to statically enable pipeline and/or bypass
// behavior. Pipeline behavior is when the deq_rdy signal is
// combinationally wired to the enq_rdy signal allowing elements to be
// dequeued and enqueued in the same cycle when the queue is full. Bypass
// behavior is when the enq_en signal is combinationally wired to the
// deq_rdy signal allowing elements to bypass the storage element if the
// storage element is empty.

module vc_QueueCtrl1
#(
  parameter p_type = `VC_QUEUE_NORMAL
)(
  input  logic clk,
  input  logic reset,

  input  logic recv_val,        // Enqueue data is valid
  output logic recv_rdy,        // Ready for producer to do an enqueue

  output logic send_val,         // Dequeue is called
  input  logic send_rdy,        // Consumer is ready to do a dequeue

  output logic write_en,       // Write en signal to wire up to storage element
  output logic bypass_mux_sel, // Used to control bypass mux for bypass queues
  output logic num_free_entries // Either zero or one
);

  // Status register

  logic full;
  logic full_next;

  always_ff @(posedge clk) begin
    full <= reset ? 1'b0 : full_next;
  end

  assign num_free_entries = full ? 1'b0 : 1'b1;

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when the call is enabled

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full;

  logic  do_pipe;
  assign do_pipe = c_pipe_en   && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the deq_val signal is also calculated combinationally
  // from the enq_val signal.

  assign recv_rdy  = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val  = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the full register input

  assign full_next = ( do_deq && ~do_pipe )   ? 1'b0
                   : ( do_enq && ~do_bypass ) ? 1'b1
                   :                            full;

endmodule

//------------------------------------------------------------------------
// Single-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for single element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath1
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1
)(
  input  logic                   clk,
  input  logic                   reset,
  input  logic                   write_en,
  input  logic                   bypass_mux_sel,
  input  logic [p_msg_nbits-1:0] recv_msg,
  output logic [p_msg_nbits-1:0] send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] qstore;

  vc_EnReg#(p_msg_nbits) qstore_reg
  (
    .clk   (clk),
    .reset (reset),
    .en    (write_en),
    .d     (recv_msg),
    .q     (qstore)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (qstore),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = qstore;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a multi-elment queue. It is designed to
// be attached to a Regfile storage element. Additionally, it includes
// the ability to statically enable pipeline and/or bypass behavior.
// Pipeline behavior is when the send_rdy signal is combinationally wired
// to the recv_rdy signal allowing elements to be dequeued and enqueued in
// the same cycle when the queue is full. Bypass behavior is when the
// recv_val signal is cominationally wired to the send_val signal allowing
// elements to bypass the storage element if the storage element is
// empty.

module vc_QueueCtrl
#(
  parameter p_type     = `VC_QUEUE_NORMAL,
  parameter p_num_msgs = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk, reset,

  input  logic                    recv_val,        // Enqueue is valid
  output logic                    recv_rdy,        // Ready for producer to enqueue

  output logic                    send_val,        // Dequeue is called
  input  logic                    send_rdy,        // Consumer is ready to dequeue

  output logic                    write_en,       // Wen to wire to regfile
  output logic [c_addr_nbits-1:0] write_addr,     // Waddr to wire to regfile
  output logic [c_addr_nbits-1:0] read_addr,      // Raddr to wire to regfile
  output logic                    bypass_mux_sel, // Control mux for bypass queues
  output logic [c_addr_nbits:0]   num_free_entries // Num of free entries in queue
);

  // Enqueue and dequeue pointers

  logic [c_addr_nbits-1:0] enq_ptr;
  logic [c_addr_nbits-1:0] enq_ptr_next;

  vc_ResetReg#(c_addr_nbits) enq_ptr_reg
  (
    .clk     (clk),
    .reset   (reset),
    .d       (enq_ptr_next),
    .q       (enq_ptr)
  );

  logic [c_addr_nbits-1:0] deq_ptr;
  logic [c_addr_nbits-1:0] deq_ptr_next;

  vc_ResetReg#(c_addr_nbits) deq_ptr_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (deq_ptr_next),
    .q     (deq_ptr)
  );

  assign write_addr = enq_ptr;
  assign read_addr  = deq_ptr;

  // Extra state to tell difference between full and empty

  logic full;
  logic full_next;

  vc_ResetReg#(1) full_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (full_next),
    .q     (full)
  );

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when they are both ready and valid

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full && (enq_ptr == deq_ptr);

  logic  do_pipe;
  assign do_pipe = c_pipe_en && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the send_val signal is also calculated combinationally
  // from the recv_val signal.

  assign recv_rdy = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the enq/deq pointers and full register

  logic [c_addr_nbits-1:0] deq_ptr_plus1;
  assign deq_ptr_plus1 = deq_ptr + 1'b1;

  /* verilator lint_off WIDTH */

  logic [c_addr_nbits-1:0] deq_ptr_inc;
  assign deq_ptr_inc = (deq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : deq_ptr_plus1;

  logic [c_addr_nbits-1:0] enq_ptr_plus1;
  assign enq_ptr_plus1 = enq_ptr + 1'b1;

  logic [c_addr_nbits-1:0] enq_ptr_inc;
  assign enq_ptr_inc = (enq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : enq_ptr_plus1;

  /* verilator lint_on WIDTH */

  assign deq_ptr_next
    = ( do_deq && ~do_bypass ) ? ( deq_ptr_inc ) : deq_ptr;

  assign enq_ptr_next
    = ( do_enq && ~do_bypass ) ? ( enq_ptr_inc ) : enq_ptr;

  assign full_next
    = ( do_enq && ~do_deq && ( enq_ptr_inc == deq_ptr ) ) ? 1'b1
    : ( do_deq && full && ~do_pipe )                      ? 1'b0
    :                                                       full;

  // Number of free entries

  assign num_free_entries
    = full                ? {(c_addr_nbits+1){1'b0}}
    : empty               ? p_num_msgs[c_addr_nbits:0]
    : (enq_ptr > deq_ptr) ? p_num_msgs[c_addr_nbits:0] - (enq_ptr - deq_ptr)
    : (deq_ptr > enq_ptr) ? deq_ptr - enq_ptr
    :                       {(c_addr_nbits+1){1'bx}};

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for multi-element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 4,
  parameter p_num_msgs  = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    write_en,
  input  logic                    bypass_mux_sel,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [c_addr_nbits-1:0] read_addr,
  input  logic [p_msg_nbits-1:0]  recv_msg,
  output logic [p_msg_nbits-1:0]  send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] read_data;

  vc_Regfile_1r1w#(p_msg_nbits,p_num_msgs) qstore
  (
    .clk        (clk),
    .reset      (reset),
    .read_addr  (read_addr),
    .read_data  (read_data),
    .write_en   (write_en),
    .write_addr (write_addr),
    .write_data (recv_msg)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (read_data),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = read_data;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Queue
//------------------------------------------------------------------------

module vc_Queue
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1,
  parameter p_num_msgs  = 2,

  // parameters not meant to be set outside this module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                   clk,
  input  logic                   reset,

  input  logic                   recv_val,
  output logic                   recv_rdy,
  input  logic [p_msg_nbits-1:0] recv_msg,

  output logic                   send_val,
  input  logic                   send_rdy,
  output logic [p_msg_nbits-1:0] send_msg,

  output logic [c_addr_nbits:0]  num_free_entries
);


  generate
  if ( p_num_msgs == 1 )
  begin

    logic write_en;
    logic bypass_mux_sel;

    vc_QueueCtrl1#(p_type) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath1#(p_type,p_msg_nbits) dpath
    (
      .clk            (clk),
      .reset          (reset),
      .write_en       (write_en),
      .bypass_mux_sel (bypass_mux_sel),
      .recv_msg       (recv_msg),
      .send_msg       (send_msg)
    );

  end
  else
  begin

    logic                    write_en;
    logic                    bypass_mux_sel;
    logic [c_addr_nbits-1:0] write_addr;
    logic [c_addr_nbits-1:0] read_addr;

    vc_QueueCtrl#(p_type,p_num_msgs) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath#(p_type,p_msg_nbits,p_num_msgs) dpath
    (
      .clk              (clk),
      .reset            (reset),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .recv_msg         (recv_msg),
      .send_msg         (send_msg)
    );

  end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( enq_en  );
      `VC_ASSERT_NOT_X( enq_rdy );
      `VC_ASSERT_NOT_X( deq_en  );
      `VC_ASSERT_NOT_X( deq_rdy );
    end
  end
  */

  // Line Tracing

  //  logic [`VC_TRACE_NBITS_TO_NCHARS(p_msg_nbits)*8-1:0] str;
  //
  //  `VC_TRACE_BEGIN
  //  begin
  //
  //    $sformat( str, "%x", enq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, enq_en, enq_rdy, str );
  //
  //    vc_trace.append_str( trace_str, "(" );
  //    $sformat( str, "%x", p_num_msgs-num_free_entries );
  //    vc_trace.append_str( trace_str, str );
  //    vc_trace.append_str( trace_str, ")" );
  //
  //    $sformat( str, "%x", deq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, deq_en, deq_rdy, str );

  // end
  // endtask

endmodule

`endif /* VC_QUEUES_V */


`line 5 "SPI_v3/components/SPIMinionAdapterVRTL.v" 0

module SPI_v3_components_SPIMinionAdapterVRTL
#(
  parameter nbits = 8,
  parameter num_entries = 1
)
(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    pull_en,
  output logic                    pull_msg_val,
  output logic                    pull_msg_spc,
  output logic [nbits-3:0]        pull_msg_data,
  input  logic                    push_en,
  input  logic                    push_msg_val_wrt,
  input  logic                    push_msg_val_rd,
  input  logic [nbits-3:0]        push_msg_data,
  input  logic [nbits-3:0]        recv_msg,
  output logic                    recv_rdy,
  input  logic                    recv_val,
  output logic [nbits-3:0]        send_msg,
  input  logic                    send_rdy,
  output logic                    send_val,
  output logic                    parity  
);

  logic open_entries;

  logic [nbits-3:0]             cm_q_send_msg;
  logic                         cm_q_send_rdy;
  logic                         cm_q_send_val;

  vc_Queue #(4'b0, nbits-2, num_entries) cm_q
  (
    .clk( clk ),
    .num_free_entries( ),
    .reset( reset ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( cm_q_send_msg ),
    .send_rdy( cm_q_send_rdy ),
    .send_val( cm_q_send_val )
  );

  logic [$clog2(num_entries):0] mc_q_num_free;
  logic                         mc_q_recv_rdy;
  logic                         mc_q_recv_val;

  vc_Queue #(4'b0, nbits-2, num_entries) mc_q
  (
    .clk( clk ),
    .num_free_entries( mc_q_num_free ),
    .reset( reset ),
    .recv_msg( push_msg_data ),
    .recv_rdy( mc_q_recv_rdy ),
    .recv_val( mc_q_recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val )
  );

  assign parity = (^send_msg) & send_val;
  
  always_comb begin : comb_block
    open_entries = mc_q_num_free > 1;
    mc_q_recv_val = push_msg_val_wrt & push_en;
    pull_msg_spc = mc_q_recv_rdy & ( ( ~mc_q_recv_val ) | open_entries );
    cm_q_send_rdy = push_msg_val_rd & pull_en;
    pull_msg_val = cm_q_send_rdy & cm_q_send_val;
    pull_msg_data = cm_q_send_msg & { (nbits-2){pull_msg_val} };
  end

endmodule

`line 6 "SPI_v3/components/SPIMinionAdapterCompositeVRTL.v" 0

module SPI_v3_components_SPIMinionAdapterCompositeVRTL
#(
  parameter nbits = 8,
  parameter num_entries = 1
)
(
  input  logic             clk,
  input  logic             cs,
  output logic             miso,
  input  logic             mosi,
  input  logic             reset,
  input  logic             sclk,
  input  logic [nbits-3:0] recv_msg,
  output logic             recv_rdy,
  input  logic             recv_val,
  output logic [nbits-3:0] send_msg,
  input  logic             send_rdy,
  output logic             send_val,
  output logic             minion_parity,
  output logic             adapter_parity
);

  logic             pull_en;
  logic             pull_msg_val;
  logic             pull_msg_spc;
  logic [nbits-3:0] pull_msg_data;
  logic             push_en;
  logic             push_msg_val_wrt;
  logic             push_msg_val_rd;
  logic [nbits-3:0] push_msg_data;

  logic [nbits-1:0] pull_msg;
  logic [nbits-1:0] push_msg;

  SPI_v3_components_SPIMinionAdapterVRTL #(nbits,num_entries) adapter
  (
    .clk( clk ),
    .reset( reset ),
    .pull_en( pull_en ),
    .pull_msg_val( pull_msg_val ),
    .pull_msg_spc(pull_msg_spc),
    .pull_msg_data(pull_msg_data),
    .push_en( push_en ),
    .push_msg_val_wrt( push_msg_val_wrt ),
    .push_msg_val_rd( push_msg_val_rd ),
    .push_msg_data( push_msg_data ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val ),
    .parity( adapter_parity )
  );

  SPI_v3_components_SPIMinionVRTL #(nbits) minion
  (
    .clk( clk ),
    .cs( cs ),
    .miso( miso ),
    .mosi( mosi ),
    .reset( reset ),
    .sclk( sclk ),
    .pull_en( pull_en ),
    .pull_msg( pull_msg ),
    .push_en( push_en ),
    .push_msg( push_msg ),
    .parity( minion_parity )
  );

  assign pull_msg[nbits-1]   =  pull_msg_val;
  assign pull_msg[nbits-2]   =  pull_msg_spc;
  assign pull_msg[nbits-3:0] =  pull_msg_data;
  assign push_msg_val_wrt = push_msg[nbits-1];
  assign push_msg_val_rd  = push_msg[nbits-2];
  assign push_msg_data    = push_msg[nbits-3:0];

endmodule

`line 10 "SPI_v3/components/SPIstackVRTL.v" 0

module SPI_v3_components_SPIstackVRTL 
#(
    parameter nbits = 34, // the size of the val/rdy msg for the SPI minion
    parameter num_entries = 1
)(
    input  logic clk,
    input  logic reset,

    input  logic loopthrough_sel,
    output logic minion_parity,
    output logic adapter_parity,

    // SPI Minion Ifc
    input  logic sclk,
    input  logic cs,
    input  logic mosi,
    output logic miso,

    // Send/Recv Ifc
    output logic                 send_val,
    output logic [(nbits-2)-1:0] send_msg,
    input  logic                 send_rdy,

    input  logic                 recv_val, 
    input  logic [(nbits-2)-1:0] recv_msg, 
    output logic                 recv_rdy
);

  logic              minion_out_val;
  logic [nbits-3:0]  minion_out_msg;
  logic              minion_out_rdy;

  logic              minion_in_val;
  logic [nbits-3:0]  minion_in_msg;
  logic              minion_in_rdy;


  SPI_v3_components_SPIMinionAdapterCompositeVRTL #(nbits, num_entries) minion
  (
    .clk( clk ),
    .reset( reset ),
    .cs( cs ),
    .miso( miso ),
    .mosi( mosi ),
    .sclk( sclk ),
    .minion_parity( minion_parity ),
    .adapter_parity( adapter_parity ),
    .recv_val( minion_in_val ),
    .recv_msg( minion_in_msg ),
    .recv_rdy( minion_in_rdy ),
    .send_val( minion_out_val ),
    .send_msg( minion_out_msg ),
    .send_rdy( minion_out_rdy )
  );

  SPI_v3_components_LoopThroughVRTL #(nbits-2) loopthrough
  (
    .clk( clk ),
    .reset( reset ),
    .sel( loopthrough_sel ),

    .upstream_req_val( minion_out_val ), 
    .upstream_req_msg( minion_out_msg ), 
    .upstream_req_rdy( minion_out_rdy ), 

    .upstream_resp_val( minion_in_val ),
    .upstream_resp_msg( minion_in_msg ),
    .upstream_resp_rdy( minion_in_rdy ),

    .downstream_req_val( send_val ), 
    .downstream_req_msg( send_msg ), 
    .downstream_req_rdy( send_rdy ), 

    .downstream_resp_val( recv_val ),
    .downstream_resp_msg( recv_msg ),
    .downstream_resp_rdy( recv_rdy )
  );


endmodule
`line 12 "tapeout/SPI_TapeOutBlockVRTL.v" 0
`line 1 "tapeout/BlockPlaceholderVRTL.v" 0
//===============================================================================
// BlockPlaceholderVRTL
//===============================================================================
// This module is connected to the SPI_stack upon release of the Tapeout folder.
// It will be replaced by the module the group is hoping to put onto the chip.
// The reason for this is that smoke tests will not pass in pymtl3 unless all the
// ports are connected.
//
// This module is simply another loopback
//
// Author : Jack Brzozowski
//   Date : May 18th, 2022


module tapeout_BlockPlaceholderVRTL
#(
    parameter nbits = 32
)(

    output logic             send_val,
    output logic [nbits-1:0] send_msg,
    input  logic             send_rdy,

    input  logic             recv_val, 
    input  logic [nbits-1:0] recv_msg, 
    output logic             recv_rdy
);

// Simple Loopback
assign send_val = recv_val;
assign send_msg = recv_msg;
assign recv_rdy = send_rdy;

endmodule
`line 13 "tapeout/SPI_TapeOutBlockVRTL.v" 0
// ADD INCLUDES HERE FOR YOUR MODULE
`line 1 "tapeout/block_test/WrapperVRTL.v" 0
`ifndef TOP_WRAPPERVRTL_V
`define TOP_WRAPPERVRTL_V

`line 1 "tapeout/block_test/Wrapper.v" 0
`ifndef TOP_WRAPPER_V
`define TOP_WRAPPER_V

`line 1 "systolic_accelerator/memory_engine/MemoryEngine.v" 0
`ifndef MEMORYENGINE
`define MEMORYENGINE

`line 1 "vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */


`line 5 "systolic_accelerator/memory_engine/MemoryEngine.v" 0
`line 1 "vc/regfiles.v" 0
//========================================================================
// Verilog Components: Register Files
//========================================================================

`ifndef VC_REGFILES_V
`define VC_REGFILES_V

//------------------------------------------------------------------------
// 1r1w register file
//------------------------------------------------------------------------

module vc_Regfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 1r1w register file with reset
//------------------------------------------------------------------------

module vc_ResetRegfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,
  parameter p_reset_value = 0,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge. We have to use a generate statement to
  // allow us to include the reset logic for each individual register.

  genvar i;
  generate
    for ( i = 0; i < p_num_entries; i = i+1 )
    begin : wport
      always_ff @( posedge clk )
        if ( reset )
          rfile[i] <= p_reset_value;
        else if ( write_en && (i[c_addr_nbits-1:0] == write_addr) )
          rfile[i] <= write_data;
    end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r1w register file
//------------------------------------------------------------------------

module vc_Regfile_2r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                   clk,
  input  logic                   reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r2w register file
//------------------------------------------------------------------------

module vc_Regfile_2r2w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en0,
  input  logic [c_addr_nbits-1:0] write_addr0,
  input  logic [p_data_nbits-1:0] write_data0,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en1,
  input  logic [c_addr_nbits-1:0] write_addr1,
  input  logic [p_data_nbits-1:0] write_data1
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk ) begin

    if ( write_en0 )
      rfile[write_addr0] <= write_data0;

    if ( write_en1 )
      rfile[write_addr1] <= write_data1;

  end

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en0 );
      `VC_ASSERT_NOT_X( write_en1 );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en0 ) begin
        `VC_ASSERT_NOT_X( write_addr0 );
        `VC_ASSERT( write_addr0 < p_num_entries );
      end

      if ( write_en1 ) begin
        `VC_ASSERT_NOT_X( write_addr1 );
        `VC_ASSERT( write_addr1 < p_num_entries );
      end

      // It is invalid to use the same write address for both write ports

      if ( write_en0 && write_en1 ) begin
        `VC_ASSERT( write_addr0 != write_addr1 );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// Register file specialized for r0 == 0
//------------------------------------------------------------------------

module vc_Regfile_2r1w_zero
(
  input  logic        clk,
  input  logic        reset,

  input  logic  [4:0] rd_addr0,
  output logic [31:0] rd_data0,

  input  logic  [4:0] rd_addr1,
  output logic [31:0] rd_data1,

  input  logic        wr_en,
  input  logic  [4:0] wr_addr,
  input  logic [31:0] wr_data
);

  // these wires are to be hooked up to the actual register file read
  // ports

  logic [31:0] rf_read_data0;
  logic [31:0] rf_read_data1;

  vc_Regfile_2r1w
  #(
    .p_data_nbits  (32),
    .p_num_entries (32)
  )
  rfile
  (
    .clk         (clk),
    .reset       (reset),
    .read_addr0  (rd_addr0),
    .read_data0  (rf_read_data0),
    .read_addr1  (rd_addr1),
    .read_data1  (rf_read_data1),
    .write_en    (wr_en),
    .write_addr  (wr_addr),
    .write_data  (wr_data)
  );

  // we pick 0 value when either read address is 0
  assign rd_data0 = ( rd_addr0 == 5'd0 ) ? 32'd0 : rf_read_data0;
  assign rd_data1 = ( rd_addr1 == 5'd0 ) ? 32'd0 : rf_read_data1;

endmodule

`endif /* VC_REGFILES_V */


`line 6 "systolic_accelerator/memory_engine/MemoryEngine.v" 0
`line 1 "systolic_accelerator/msg_structs/data_type.v" 0
`ifndef DATATYPE
`define DATATYPE
parameter INT_WIDTH = 8;
parameter FRAC_WIDTH = 8;
`endif /*DATATYPE*/
`line 7 "systolic_accelerator/memory_engine/MemoryEngine.v" 0

module MemoryEngine #(
    parameter DATA_ENTRIES
)
(
    input clk,
    input reset,

    output logic recv_rdy,
    input logic recv_val,
    input [INT_WIDTH + FRAC_WIDTH+2-1:0] recv_msg,

    input logic send_rdy,
    output logic send_val,
    output [INT_WIDTH + FRAC_WIDTH-1:0] send_msg
);
logic [INT_WIDTH+FRAC_WIDTH-1 : 0] recv_msg_wrt_data;
logic recv_msg_run;
parameter MODE = 1;
parameter RUN = 0;
assign recv_msg_wrt_data = recv_msg[INT_WIDTH + FRAC_WIDTH+2-1:2];
assign recv_msg_run = recv_msg[1] && recv_msg[0] && recv_val;
logic [$clog2(DATA_ENTRIES)-1 : 0] wrt_addr;
always@(posedge clk) begin
    if (reset) begin
        wrt_addr <= 'b0;
    end
    else if (recv_val && recv_rdy) begin
        if (recv_msg_run)
            wrt_addr <= 'b0;
        else
            wrt_addr <= wrt_addr + 1;
    end
    else
        wrt_addr <= wrt_addr;
end

logic stop_output;
logic counter_full;
logic [ INT_WIDTH + FRAC_WIDTH - 1: 0 ] data_temp;
logic send_val_temp;
assign send_msg = send_val ? data_temp : 'b0;
assign send_val = ~counter_full && send_val_temp;
regfile_ReadRegfileDpath #(
    .DATA_WIDTH(INT_WIDTH + FRAC_WIDTH),
    .DATA_ENTRIES(DATA_ENTRIES)
) dpath
(
    .clk(clk),
    .reset(reset),
    .wrt_en(recv_val&&~recv_msg[1]),
    .stop_output(stop_output),
    .send_rdy(send_rdy),
    .wrt_addr(wrt_addr),
    .wrt_data(recv_msg_wrt_data),
    .data(data_temp),
    .counter_full(counter_full)
);

read_regfile_Cpath #(
    .DATA_WIDTH(INT_WIDTH + FRAC_WIDTH),
    .DATA_ENTRIES(DATA_ENTRIES)
) cpath
(
    .clk(clk),
    .reset(reset),
    .run(recv_msg_run),
    .counter_full(counter_full),
    .stop_output(stop_output),
    .send_val(send_val_temp),
    .recv_rdy(recv_rdy)
);

endmodule

module regfile_ReadRegfileDpath
#(
    parameter DATA_WIDTH,
    parameter DATA_ENTRIES
)
(
    input logic clk,
    input logic reset,

    input logic wrt_en,
    input logic stop_output,
    input logic send_rdy,
    input logic [ $clog2(DATA_ENTRIES) - 1: 0 ] wrt_addr,
    input logic [ DATA_WIDTH - 1: 0 ] wrt_data,

    output logic [ DATA_WIDTH - 1: 0 ] data,
    output logic counter_full

);
    logic [$clog2(DATA_ENTRIES) : 0] counter;

    vc_Regfile_1r1w #(.p_data_nbits(DATA_WIDTH),
                      .p_num_entries(DATA_ENTRIES)) regFile (
        .clk(clk),
        .reset(reset),
        .read_addr(counter[$clog2(DATA_ENTRIES)-1 : 0]),
        .read_data(data),
        .write_en(wrt_en),
        .write_addr(wrt_addr),
        .write_data(wrt_data)
    );

    assign counter_full = counter == DATA_ENTRIES;

    always @(posedge clk) begin
        if(reset) begin
            counter <= 0;
        end
        else begin
            if (send_rdy)
                counter <= stop_output ? 'b0 : counter + 1;
            else
                counter <= stop_output ? 'b0 : counter;
        end 
    end 

endmodule


module read_regfile_Cpath
#(
    parameter DATA_WIDTH,
    parameter DATA_ENTRIES
)
(
    input logic clk,
    input logic reset,

    input logic run,
    input logic counter_full,
    output logic stop_output,
    output logic send_val,
    output logic recv_rdy
);
    typedef enum
    {   STATE_WAIT,
        STATE_READ  } states;

    states state_reg;
    states state_next;

    always @(posedge clk) begin
        if (reset)
            state_reg <= STATE_WAIT;
        else begin
            state_reg <= state_next;
        end
    end 

    always @(*) begin
        state_next = state_reg;
        stop_output = 'b1;
        send_val = 'b0;
        recv_rdy = 'b0;
        case ( state_reg )
            STATE_WAIT: 
            begin
                recv_rdy = 1'b1;
                if (run) begin
                    state_next = STATE_READ;
                end
            end
            STATE_READ:
            begin
                send_val = 'b1;
                if (counter_full) begin
                    state_next = STATE_WAIT;
                end
                else begin
                    stop_output = 'b0;
                end
            end 
            default: state_next = STATE_WAIT;
        endcase 
    end 

endmodule

`endif /*MEMORYENGINE*/
`line 5 "tapeout/block_test/Wrapper.v" 0
`line 1 "systolic_accelerator/memory_engine/MemoryEngineLat.v" 0
`ifndef MEMORYENGINELAT
`define MEMORYENGINELAT

`line 1 "vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */


`line 5 "systolic_accelerator/memory_engine/MemoryEngineLat.v" 0
`line 1 "vc/regfiles.v" 0
//========================================================================
// Verilog Components: Register Files
//========================================================================

`ifndef VC_REGFILES_V
`define VC_REGFILES_V

//------------------------------------------------------------------------
// 1r1w register file
//------------------------------------------------------------------------

module vc_Regfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 1r1w register file with reset
//------------------------------------------------------------------------

module vc_ResetRegfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,
  parameter p_reset_value = 0,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge. We have to use a generate statement to
  // allow us to include the reset logic for each individual register.

  genvar i;
  generate
    for ( i = 0; i < p_num_entries; i = i+1 )
    begin : wport
      always_ff @( posedge clk )
        if ( reset )
          rfile[i] <= p_reset_value;
        else if ( write_en && (i[c_addr_nbits-1:0] == write_addr) )
          rfile[i] <= write_data;
    end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r1w register file
//------------------------------------------------------------------------

module vc_Regfile_2r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                   clk,
  input  logic                   reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r2w register file
//------------------------------------------------------------------------

module vc_Regfile_2r2w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en0,
  input  logic [c_addr_nbits-1:0] write_addr0,
  input  logic [p_data_nbits-1:0] write_data0,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en1,
  input  logic [c_addr_nbits-1:0] write_addr1,
  input  logic [p_data_nbits-1:0] write_data1
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk ) begin

    if ( write_en0 )
      rfile[write_addr0] <= write_data0;

    if ( write_en1 )
      rfile[write_addr1] <= write_data1;

  end

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en0 );
      `VC_ASSERT_NOT_X( write_en1 );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en0 ) begin
        `VC_ASSERT_NOT_X( write_addr0 );
        `VC_ASSERT( write_addr0 < p_num_entries );
      end

      if ( write_en1 ) begin
        `VC_ASSERT_NOT_X( write_addr1 );
        `VC_ASSERT( write_addr1 < p_num_entries );
      end

      // It is invalid to use the same write address for both write ports

      if ( write_en0 && write_en1 ) begin
        `VC_ASSERT( write_addr0 != write_addr1 );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// Register file specialized for r0 == 0
//------------------------------------------------------------------------

module vc_Regfile_2r1w_zero
(
  input  logic        clk,
  input  logic        reset,

  input  logic  [4:0] rd_addr0,
  output logic [31:0] rd_data0,

  input  logic  [4:0] rd_addr1,
  output logic [31:0] rd_data1,

  input  logic        wr_en,
  input  logic  [4:0] wr_addr,
  input  logic [31:0] wr_data
);

  // these wires are to be hooked up to the actual register file read
  // ports

  logic [31:0] rf_read_data0;
  logic [31:0] rf_read_data1;

  vc_Regfile_2r1w
  #(
    .p_data_nbits  (32),
    .p_num_entries (32)
  )
  rfile
  (
    .clk         (clk),
    .reset       (reset),
    .read_addr0  (rd_addr0),
    .read_data0  (rf_read_data0),
    .read_addr1  (rd_addr1),
    .read_data1  (rf_read_data1),
    .write_en    (wr_en),
    .write_addr  (wr_addr),
    .write_data  (wr_data)
  );

  // we pick 0 value when either read address is 0
  assign rd_data0 = ( rd_addr0 == 5'd0 ) ? 32'd0 : rf_read_data0;
  assign rd_data1 = ( rd_addr1 == 5'd0 ) ? 32'd0 : rf_read_data1;

endmodule

`endif /* VC_REGFILES_V */


`line 6 "systolic_accelerator/memory_engine/MemoryEngineLat.v" 0
`line 1 "systolic_accelerator/msg_structs/data_type.v" 0
`ifndef DATATYPE
`define DATATYPE
parameter INT_WIDTH = 8;
parameter FRAC_WIDTH = 8;
`endif /*DATATYPE*/
`line 7 "systolic_accelerator/memory_engine/MemoryEngineLat.v" 0

module MemoryEngineLat #(
    parameter DATA_ENTRIES,
    parameter DATA_LAT
)
(
    input clk,
    input reset,

    output logic recv_rdy,
    input logic recv_val,
    input [INT_WIDTH + FRAC_WIDTH+2-1:0] recv_msg,

    input logic send_rdy,
    output logic send_val,
    output [INT_WIDTH + FRAC_WIDTH-1:0] send_msg
);
logic [INT_WIDTH+FRAC_WIDTH-1 : 0] recv_msg_wrt_data;
logic recv_msg_run;
parameter MODE = 1;
parameter RUN = 0;
assign recv_msg_wrt_data = recv_msg[INT_WIDTH + FRAC_WIDTH+2-1:2];
assign recv_msg_run = recv_msg[1] && recv_msg[0] && recv_val;
logic [$clog2(DATA_ENTRIES)-1 : 0] wrt_addr;

logic stop_output;
logic lat_en;
logic counter_full;
logic counter_lat_finish;

always@(posedge clk) begin
    if (reset) begin
        wrt_addr <= 'b0;
    end
    else if (recv_val && recv_rdy) begin
        if (recv_msg_run)
            wrt_addr <= 'b0;
        else
            wrt_addr <= wrt_addr + 1;
    end
    else
        wrt_addr <= wrt_addr;
end

logic [ INT_WIDTH+FRAC_WIDTH - 1: 0 ] data_temp;
assign send_msg = send_val ? data_temp : 'b0;

regfile_ReadRegfileLatDpath #(
    .DATA_WIDTH(INT_WIDTH+FRAC_WIDTH),
    .DATA_ENTRIES(DATA_ENTRIES),
    .DATA_LAT(DATA_LAT)
) dpath
(
    .clk(clk),
    .reset(reset),
    .wrt_en(recv_val&&~recv_msg[1]),
    .stop_output(stop_output),
    .send_rdy(send_rdy),
    .wrt_addr(wrt_addr),
    .wrt_data(recv_msg_wrt_data),
    .data(data_temp),
    .counter_full(counter_full),
    .counter_lat_finish(counter_lat_finish),
    .lat_en(lat_en)
);

read_regfileLat_Cpath #(
    .DATA_WIDTH(INT_WIDTH+FRAC_WIDTH),
    .DATA_ENTRIES(DATA_ENTRIES)
) cpath
(
    .clk(clk),
    .reset(reset),
    .run(recv_msg_run),
    .counter_full(counter_full),
    .stop_output(stop_output),
    .counter_lat_finish(counter_lat_finish),
    .lat_en(lat_en),
    .send_val(send_val),
    .recv_rdy(recv_rdy)
);

endmodule

module regfile_ReadRegfileLatDpath
#(
    parameter DATA_WIDTH,
    parameter DATA_ENTRIES,
    parameter DATA_LAT
)
(
    input logic clk,
    input logic reset,

    input logic wrt_en,
    input logic lat_en,
    input logic stop_output,
    input logic send_rdy,
    input logic [ $clog2(DATA_ENTRIES) - 1: 0 ] wrt_addr,
    input logic [ DATA_WIDTH - 1: 0 ] wrt_data,

    output logic [ DATA_WIDTH - 1: 0 ] data,
    output logic counter_full,
    output logic counter_lat_finish

);

    logic [$clog2(DATA_ENTRIES) - 1: 0] counter;
    logic [$clog2(DATA_ENTRIES) - 1: 0] counter_lat;

    vc_Regfile_1r1w #(.p_data_nbits(DATA_WIDTH),
                      .p_num_entries(DATA_ENTRIES)) regFile (
        .clk(clk),
        .reset(reset),
        .read_addr(counter),
        .read_data(data),
        .write_en(wrt_en),
        .write_addr(wrt_addr),
        .write_data(wrt_data)
    );

    assign counter_full = counter == DATA_ENTRIES-1;
    assign counter_lat_finish = counter_lat == DATA_LAT;

    always @(posedge clk) begin
        if(reset) begin
            counter <= 0;
            counter_lat <= 0;
        end
        else begin 
            if (send_rdy)
                counter <= stop_output ? 'b0 : counter + 1;
            else
                counter <= stop_output ? 'b0 : counter;
            counter_lat <= lat_en ? counter_lat + 1 : 'b0;
        end 
    end 

endmodule


module read_regfileLat_Cpath
#(
    parameter DATA_WIDTH,
    parameter DATA_ENTRIES
)
(
    input logic clk,
    input logic reset,

    input logic run,
    input logic counter_full,
    input logic counter_lat_finish,

    output logic lat_en,
    output logic stop_output,
    output logic send_val,
    output logic recv_rdy
);

    typedef enum
    {   STATE_WAIT,
        STATE_READ,
        STATE_LAT
    } states;

    states state_reg;
    states state_next;

    always @(posedge clk) begin
        if (reset)
            state_reg <= STATE_WAIT;
        else begin
            state_reg <= state_next;
        end
    end 

    always @(*) begin
        state_next = state_reg;
        stop_output = 'b1;
        lat_en = 'b0;
        send_val = 'b0;
        recv_rdy = 'b0;
        case ( state_reg )
            STATE_WAIT: 
            begin
                recv_rdy = 'b1;
                if (run) begin
                    state_next = STATE_LAT;
                end
            end

            STATE_LAT:
            begin
                lat_en = 'b1;
                if (counter_lat_finish) begin
                    state_next = STATE_READ;
                end  
            end

            STATE_READ:
            begin
                send_val = 'b1;
                if (counter_full) begin
                    state_next = STATE_WAIT;
                end
                else begin
                    stop_output = 'b0;
                end
            end 
            
            default: state_next = STATE_WAIT;
        endcase 
    end 

endmodule

`endif /*MEMORYENGINELAT*/
`line 6 "tapeout/block_test/Wrapper.v" 0
`line 1 "systolic_accelerator/systolic_mult/SystolicMult.v" 0
//========================================================================
// Integer Multiplier Fixed-Latency Implementation
//========================================================================

`line 1 "vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */


`line 6 "systolic_accelerator/systolic_mult/SystolicMult.v" 0
`line 1 "systolic_accelerator/systolic_mult/Pe.v" 0
//========================================================================
// Integer Multiplier Fixed-Latency Implementation
//========================================================================
`line 1 "vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */


`line 5 "systolic_accelerator/systolic_mult/Pe.v" 0
`line 1 "systolic_accelerator/systolic_mult/FixedMult.v" 0
module FixedMult #(
// parameter for fixed point number, default is 11.5 (include sign bit)
 parameter INT_WIDTH,
 parameter FRAC_WIDTH
)
(input logic  signed [INT_WIDTH + FRAC_WIDTH - 1:0] a,
 input logic signed [INT_WIDTH + FRAC_WIDTH - 1:0] b,
 output logic signed [INT_WIDTH + FRAC_WIDTH - 1:0] result
 );

logic signed [2* (INT_WIDTH + FRAC_WIDTH) - 1 : 0] partial;
assign partial =  a * b;
assign result = partial [  INT_WIDTH + 2 * FRAC_WIDTH - 1: FRAC_WIDTH] ;

endmodule
`line 6 "systolic_accelerator/systolic_mult/Pe.v" 0

// ''' LAB TASK ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
// Define datapath and control unit here.
// '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
module Pe 
#(
	parameter INT_WIDTH,
	parameter FRAC_WIDTH
)
(
  input logic reset,
  input logic clk,
  input logic [INT_WIDTH+FRAC_WIDTH-1 : 0] a,
  input logic [INT_WIDTH+FRAC_WIDTH-1 : 0] b,
  input logic shift_result,
  input logic finished,
  output logic pass_shift_result,
  output logic reg_finished,
  output logic [INT_WIDTH+FRAC_WIDTH-1 : 0] reg_pass_down, 
  output logic [INT_WIDTH+FRAC_WIDTH-1 : 0] reg_pass_right
);

assign pass_shift_result = shift_result;

logic [INT_WIDTH+FRAC_WIDTH-1:0] reg_output;
logic [INT_WIDTH+FRAC_WIDTH-1 :0] fixed_mult_result;

FixedMult #(
  INT_WIDTH,
  FRAC_WIDTH
)
fixed_mult (
  .a(a),
  .b(b),
  .result(fixed_mult_result)
);

logic [INT_WIDTH+FRAC_WIDTH-1 : 0] sum_result;
assign sum_result = reg_output + fixed_mult_result;

logic [INT_WIDTH+FRAC_WIDTH-1 : 0] reg_pass_down_in, reg_pass_right_in, reg_output_in;
assign reg_pass_down_in = shift_result ? reg_output : a;
assign reg_pass_right_in = shift_result ? reg_pass_right : b;
assign reg_output_in = shift_result ? 0 : reg_finished ? reg_output : sum_result;

always @(posedge clk )begin
  if(reset) begin
    reg_pass_down <= 0;
    reg_pass_right <= 0;
    reg_output  <= 0;
    reg_finished <= 0;
  end
  //TODO: clk gating?
  else begin  
    reg_finished <= finished;
    reg_output <= reg_output_in;
    reg_pass_down <= reg_pass_down_in; //for reuse
    reg_pass_right <= reg_pass_right_in; //for reuse
  end
end



endmodule
`line 7 "systolic_accelerator/systolic_mult/SystolicMult.v" 0
`line 1 "systolic_accelerator/systolic_mult/SystolicMultControl.v" 0
module SystolicMultControl #(
// parameter for fixed point number, default is 11.5 (include sign bit)
 parameter SYSTOLIC_SIZE,
 parameter SYSTOLIC_STEP_SIZE
)
(input logic clk,
 input logic reset,
 input logic run,
 input logic final_run,
 output logic shift_result,
 output logic finished,
 output logic val,
 output logic ready,
 output logic produce_run
 );

logic [$clog2(SYSTOLIC_STEP_SIZE*2) - 1 : 0] count;
logic count_start;
always@(posedge clk) begin
    if (reset)
        count <= 'b0;
    else
        count <=  count_start ? count + 1'b1 : 0;
end

typedef enum
{ STATE_WAIT,
  STATE_RUN,
  STATE_RUN_CONTINUOUS,
  STATE_FINISH,
  STATE_FINISHWAIT,
  STATE_SHIFT,
  STATE_SHIFTWAIT0,
  STATE_SHIFTWAIT1,
  STATE_READ_VAL} states;

states current_state, next_state;

logic run_done;
assign run_done =  (count == SYSTOLIC_STEP_SIZE-2) && current_state == STATE_RUN;
logic finish_done;
assign finish_done =  (count == (SYSTOLIC_STEP_SIZE-2+SYSTOLIC_SIZE))  && current_state == STATE_FINISH;

always @( posedge clk ) begin
  if ( reset )
    current_state <= STATE_WAIT;
  else
    current_state <= next_state;
end

always@(*) begin
  next_state = current_state;
  shift_result = 'b0;
  finished = 'b0;
  count_start = 'b0;
  ready = 'b0;
  val = 'b0;
  produce_run = 'b0;
  case ( current_state )
    STATE_WAIT: begin
      if (run) begin
        if (final_run) next_state = STATE_RUN;
        else next_state = STATE_RUN_CONTINUOUS;
      end
      ready = 'b1;
      shift_result = 'b1;
    end
    STATE_RUN_CONTINUOUS: begin
      ready = 'b1;
      if (final_run)
        next_state = STATE_RUN;
    end
    STATE_RUN: begin
      if (run_done)
        next_state = STATE_FINISH;
      count_start = 'b1;
    end
    STATE_FINISH: begin
      if (finish_done)
        next_state = STATE_FINISHWAIT;
      finished = 'b1;
      count_start = 'b1;
    end
    STATE_FINISHWAIT: begin
      next_state = STATE_SHIFT;
    end
    STATE_SHIFT: begin
      next_state = STATE_SHIFTWAIT0;
      shift_result = 1'b1;
    end
    STATE_SHIFTWAIT0: begin
      next_state = STATE_SHIFTWAIT1;
      val = 'b1;
    end
    STATE_SHIFTWAIT1: begin
      next_state = STATE_READ_VAL;
      val = 'b1;
    end
    STATE_READ_VAL: begin
      next_state = STATE_WAIT;
      produce_run = 'b1;
    end
    default: next_state = STATE_WAIT;
  endcase 
end


endmodule
`line 8 "systolic_accelerator/systolic_mult/SystolicMult.v" 0
`line 1 "systolic_accelerator/msg_structs/data_type.v" 0
`ifndef DATATYPE
`define DATATYPE
parameter INT_WIDTH = 8;
parameter FRAC_WIDTH = 8;
`endif /*DATATYPE*/
`line 9 "systolic_accelerator/systolic_mult/SystolicMult.v" 0
// ''' LAB TASK ''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
// Define datapath and control unit here.
// '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
module SystolicMult #(
	parameter INT_WIDTH,
	parameter FRAC_WIDTH,
  parameter SYSTOLIC_SIZE,
  parameter SYSTOLIC_STEP_SIZE
)
(
  input logic reset,
  input logic clk,

  input [(INT_WIDTH + FRAC_WIDTH)*4+3-1:0] recv_msg,
  input logic recv_val,
  output logic recv_rdy,

  output [(INT_WIDTH + FRAC_WIDTH)*2-1:0] send_msg,
  output logic send_val,
  input logic send_rdy,
  output logic produce_run
);

logic finished, shift_result;
SystolicMultControl #(
// parameter for fixed point number, default is 11.5 (include sign bit)
 .SYSTOLIC_SIZE(SYSTOLIC_SIZE),
 .SYSTOLIC_STEP_SIZE(SYSTOLIC_STEP_SIZE)
) systolicMultControl
( .clk(clk),
  .reset(reset),
  .run(recv_msg[1]),
  .final_run(recv_msg[0]),
  .shift_result(shift_result),
  .finished(finished),
  .val(send_val),
  .ready(recv_rdy),
  .produce_run(produce_run)
 );

parameter NUM_INTERCONNECT_1D = (SYSTOLIC_SIZE-1) * SYSTOLIC_SIZE;
// logic [NUM_INTERCONNECT_1D-1:0] [INT_WIDTH + FRAC_WIDTH - 1:0] pass_a, pass_b;
logic [INT_WIDTH + FRAC_WIDTH - 1:0] pass_a_0, pass_b_0;
logic [INT_WIDTH + FRAC_WIDTH - 1:0] pass_a_1, pass_b_1;

logic [SYSTOLIC_SIZE-1:0] pass_shift_result, reg_finished;
Pe #(
  INT_WIDTH,
  FRAC_WIDTH
  ) 
  pe0 (	
    .clk(clk),
    .reset(reset),
    .a(recv_msg[(INT_WIDTH+FRAC_WIDTH)*2+3-1:(INT_WIDTH+FRAC_WIDTH)*1+3]), 
    .b(recv_msg[(INT_WIDTH+FRAC_WIDTH)*4+3-1:(INT_WIDTH+FRAC_WIDTH)*3+3]),
    .shift_result(shift_result),
    .finished(finished),
    .pass_shift_result(pass_shift_result[0]),
    .reg_finished(reg_finished[0]),
    // .reg_pass_down(pass_a[0]),
    // .reg_pass_right(pass_b[0])
    .reg_pass_down(pass_a_0),
    .reg_pass_right(pass_b_0)
);
Pe #(
  INT_WIDTH,
  FRAC_WIDTH
  ) 
  pe1 (	
    .clk(clk),
    .reset(reset),
    .a(recv_msg[(INT_WIDTH+FRAC_WIDTH)*1+3-1:3]), 
    // .b(pass_b[0]),
    .b(pass_b_0),
    .shift_result(pass_shift_result[0]),
    .finished(reg_finished[0]),
    .pass_shift_result(pass_shift_result[1]),
    .reg_finished(reg_finished[1]),
    // .reg_pass_down(pass_a[1]),
    .reg_pass_down(pass_a_1),
    .reg_pass_right()
);
Pe #(
  INT_WIDTH,
  FRAC_WIDTH
  ) 
  pe2 (	
    .clk(clk),
    .reset(reset),
    // .a(pass_a[0]), 
    .a(pass_a_0), 
    .b(recv_msg[(INT_WIDTH+FRAC_WIDTH)*3+3-1:(INT_WIDTH+FRAC_WIDTH)*2+3]),
    .shift_result(pass_shift_result[0]),
    .finished(reg_finished[0]),
    .pass_shift_result(),
    .reg_finished(),
    .reg_pass_down(send_msg[(INT_WIDTH+FRAC_WIDTH)*2-1:(INT_WIDTH+FRAC_WIDTH)]),
    // .reg_pass_right(pass_b[1])
    .reg_pass_right(pass_b_1)
);
Pe #(
  INT_WIDTH,
  FRAC_WIDTH
  ) 
  pe3 (	
    .clk(clk),
    .reset(reset),
    // .a(pass_a[1]),
    // .b(pass_b[1]),
    .a(pass_a_1),
    .b(pass_b_1),
    .shift_result(pass_shift_result[1]),
    .finished(reg_finished[1]),
    .pass_shift_result(),
    .reg_finished(),
    .reg_pass_down(send_msg[INT_WIDTH + FRAC_WIDTH - 1:0]),
    .reg_pass_right()
);


endmodule
`line 7 "tapeout/block_test/Wrapper.v" 0
`line 1 "systolic_accelerator/msg_structs/data_type.v" 0
`ifndef DATATYPE
`define DATATYPE
parameter INT_WIDTH = 8;
parameter FRAC_WIDTH = 8;
`endif /*DATATYPE*/
`line 8 "tapeout/block_test/Wrapper.v" 0

module Wrapper #
(
    parameter DATA_ENTRIES,
    parameter DATA_LAT,

    parameter INT_WIDTH,
	parameter FRAC_WIDTH,
    parameter SYSTOLIC_SIZE,
    parameter SYSTOLIC_STEP_SIZE
)
(
    input clk,
    input reset,

    input logic send_rdy, // TODO, need halt
    output logic send_val,
    output [(INT_WIDTH+FRAC_WIDTH)*2-1:0] send_msg,

    input logic recv_val,
	output logic recv_rdy,
    input [INT_WIDTH+FRAC_WIDTH+4+3-1:0] recv_msg // share by 4
);
logic [(INT_WIDTH + FRAC_WIDTH)*4+3-1:0] systolic_mult_0_recv_msg;
logic [(INT_WIDTH + FRAC_WIDTH)*2-1:0] systolic_mult_0_send_msg;
logic systolic_mult_0_send_val;
logic systolic_mult_0_send_rdy;
logic systolic_mult_0_recv_val;
logic systolic_mult_0_recv_rdy;

logic [INT_WIDTH + FRAC_WIDTH+2-1:0] memory_engine_in_0_recv_msg;
logic [INT_WIDTH + FRAC_WIDTH+2-1:0] memory_engine_in_1_recv_msg;
logic [INT_WIDTH + FRAC_WIDTH+2-1:0] memory_engine_in_2_recv_msg;
logic [INT_WIDTH + FRAC_WIDTH+2-1:0] memory_engine_in_3_recv_msg;
logic [INT_WIDTH + FRAC_WIDTH-1:0] memory_engine_in_0_send_msg;
logic [INT_WIDTH + FRAC_WIDTH-1:0] memory_engine_in_1_send_msg;
logic [INT_WIDTH + FRAC_WIDTH-1:0] memory_engine_in_2_send_msg;
logic [INT_WIDTH + FRAC_WIDTH-1:0] memory_engine_in_3_send_msg;
logic memory_engine_in_0_send_val;
logic memory_engine_in_1_send_val;
logic memory_engine_in_2_send_val;
logic memory_engine_in_3_send_val;
logic memory_engine_in_0_send_rdy;
logic memory_engine_in_1_send_rdy;
logic memory_engine_in_2_send_rdy;
logic memory_engine_in_3_send_rdy;
logic memory_engine_in_0_recv_val;
logic memory_engine_in_1_recv_val;
logic memory_engine_in_2_recv_val;
logic memory_engine_in_3_recv_val;
logic memory_engine_in_0_recv_rdy;
logic memory_engine_in_1_recv_rdy;
logic memory_engine_in_2_recv_rdy;
logic memory_engine_in_3_recv_rdy;

logic [INT_WIDTH + FRAC_WIDTH+2-1:0] memory_engine_out_0_recv_msg;
logic [INT_WIDTH + FRAC_WIDTH-1:0] memory_engine_out_0_send_msg;
logic [INT_WIDTH + FRAC_WIDTH+2-1:0] memory_engine_out_1_recv_msg;
logic [INT_WIDTH + FRAC_WIDTH-1:0]  memory_engine_out_1_send_msg;
logic memory_engine_out_0_send_val;
logic memory_engine_out_1_send_val;
logic memory_engine_out_0_send_rdy;
logic memory_engine_out_1_send_rdy;
logic memory_engine_out_0_recv_val;
logic memory_engine_out_1_recv_val;
logic memory_engine_out_0_recv_rdy;
logic memory_engine_out_1_recv_rdy;

assign send_val = memory_engine_out_0_send_val && memory_engine_out_1_send_val;
assign recv_rdy = systolic_mult_0_recv_rdy&&memory_engine_in_3_recv_rdy;

assign send_msg[(INT_WIDTH+FRAC_WIDTH)*2-1:(INT_WIDTH+FRAC_WIDTH)*1] = memory_engine_out_0_send_msg;
assign send_msg[(INT_WIDTH+FRAC_WIDTH)*1-1:0] = memory_engine_out_1_send_msg;

assign memory_engine_in_0_recv_msg[INT_WIDTH+FRAC_WIDTH+2-1:2] = recv_msg[INT_WIDTH+FRAC_WIDTH+4+3-1:7];
assign memory_engine_in_0_recv_msg[1] = recv_msg[2];
assign memory_engine_in_0_recv_msg[0] = recv_msg[1];
// From left to right 
MemoryEngine #(
    .DATA_ENTRIES(DATA_ENTRIES)
) memoryEngine_a
(
    .clk(clk),
    .reset(reset),
    .recv_rdy(),
    .recv_val(recv_val&&recv_msg[3]&&recv_rdy),
    .recv_msg(memory_engine_in_0_recv_msg),
    .send_rdy(1'b1),
    .send_val(),
    .send_msg(memory_engine_in_0_send_msg)
);

assign memory_engine_in_1_recv_msg[INT_WIDTH+FRAC_WIDTH+2-1:2] = recv_msg[INT_WIDTH+FRAC_WIDTH+4+3-1:7];
assign memory_engine_in_1_recv_msg[1] = recv_msg[2];
assign memory_engine_in_1_recv_msg[0] = recv_msg[1];
MemoryEngineLat #(
    .DATA_ENTRIES(DATA_ENTRIES),
    .DATA_LAT(DATA_LAT)
) memoryEngineLat_a
(
    .clk(clk),
    .reset(reset),
    .recv_rdy(),
    .recv_val(recv_val&&recv_msg[4]&&recv_rdy),
    .recv_msg(memory_engine_in_1_recv_msg),
    .send_rdy(1'b1),
    .send_val(),
    .send_msg(memory_engine_in_1_send_msg)
);

// From top to bottom
assign memory_engine_in_2_recv_msg[INT_WIDTH+FRAC_WIDTH+2-1:2] = recv_msg[INT_WIDTH+FRAC_WIDTH+4+3-1:7];
assign memory_engine_in_2_recv_msg[1] = recv_msg[2];
assign memory_engine_in_2_recv_msg[0] = recv_msg[1];
MemoryEngine #(
    .DATA_ENTRIES(DATA_ENTRIES)
) memoryEngine_b
(
    .clk(clk),
    .reset(reset),
    .recv_rdy(),
    .recv_val(recv_val&&recv_msg[5]&&recv_rdy),
    .recv_msg(memory_engine_in_2_recv_msg),
    .send_rdy(1'b1),
    .send_val(),
    .send_msg(memory_engine_in_2_send_msg)
);

assign memory_engine_in_3_recv_msg[INT_WIDTH+FRAC_WIDTH+2-1:2] = recv_msg[INT_WIDTH+FRAC_WIDTH+4+3-1:7];
assign memory_engine_in_3_recv_msg[1] = recv_msg[2];
assign memory_engine_in_3_recv_msg[0] = recv_msg[1];
MemoryEngineLat #(
    .DATA_ENTRIES(DATA_ENTRIES),
    .DATA_LAT(DATA_LAT)
) memoryEngineLat_b
(
    .clk(clk),
    .reset(reset),
    .recv_rdy(memory_engine_in_3_recv_rdy),
    .recv_val(recv_val&&recv_msg[6]&&recv_rdy),
    .recv_msg(memory_engine_in_3_recv_msg),
    .send_rdy(1'b1),
    .send_val(),
    .send_msg(memory_engine_in_3_send_msg)
);

// Systolic multiplication 
logic produce_run;
assign systolic_mult_0_recv_msg[(INT_WIDTH+FRAC_WIDTH)*4+3-1:(INT_WIDTH+FRAC_WIDTH)*3+3] = memory_engine_in_0_send_msg;
assign systolic_mult_0_recv_msg[(INT_WIDTH+FRAC_WIDTH)*3+3-1:(INT_WIDTH+FRAC_WIDTH)*2+3] = memory_engine_in_1_send_msg;
assign systolic_mult_0_recv_msg[(INT_WIDTH+FRAC_WIDTH)*2+3-1:(INT_WIDTH+FRAC_WIDTH)*1+3] = memory_engine_in_2_send_msg;
assign systolic_mult_0_recv_msg[(INT_WIDTH+FRAC_WIDTH)*1+3-1:(INT_WIDTH+FRAC_WIDTH)*0+3] = memory_engine_in_3_send_msg;
assign systolic_mult_0_recv_msg[2] = recv_msg[2];
assign systolic_mult_0_recv_msg[1] = recv_msg[1];
assign systolic_mult_0_recv_msg[0] = recv_msg[0];
SystolicMult #(
    .INT_WIDTH(INT_WIDTH),
	.FRAC_WIDTH(FRAC_WIDTH),
    .SYSTOLIC_SIZE(SYSTOLIC_SIZE),
    .SYSTOLIC_STEP_SIZE(SYSTOLIC_STEP_SIZE)
) systolicMult
(
    .reset(reset),
    .clk(clk),
    .recv_msg(systolic_mult_0_recv_msg),
    .recv_rdy(systolic_mult_0_recv_rdy),
    .recv_val(),

    .send_msg(systolic_mult_0_send_msg),
    .produce_run(produce_run),
    .send_val(systolic_mult_0_send_val),
    .send_rdy()

);

assign memory_engine_out_0_recv_msg[INT_WIDTH + FRAC_WIDTH+2-1:2] = systolic_mult_0_send_msg[(INT_WIDTH+FRAC_WIDTH)*2-1:(INT_WIDTH+FRAC_WIDTH)];
assign memory_engine_out_0_recv_msg[1] = produce_run;
assign memory_engine_out_0_recv_msg[0] = produce_run;
assign memory_engine_out_0_send_rdy = send_rdy;
MemoryEngine #(
    .DATA_ENTRIES(2)
) memoryEngineOut0
(
    .clk(clk),
    .reset(reset),
    .recv_rdy(),
    .recv_val(systolic_mult_0_send_val||produce_run),
    .recv_msg(memory_engine_out_0_recv_msg),
    .send_rdy(memory_engine_out_0_send_rdy),
    .send_val(memory_engine_out_0_send_val),
    .send_msg(memory_engine_out_0_send_msg)
);

assign memory_engine_out_1_recv_msg[INT_WIDTH + FRAC_WIDTH+2-1:2] = systolic_mult_0_send_msg[(INT_WIDTH+FRAC_WIDTH)*1-1:0];
assign memory_engine_out_1_recv_msg[1] = produce_run;
assign memory_engine_out_1_recv_msg[0] = produce_run;
assign memory_engine_out_1_send_rdy = send_rdy;
MemoryEngine #(
    .DATA_ENTRIES(2)
) memoryEngineOut1
(
    .clk(clk),
    .reset(reset),
    .recv_rdy(),
    .recv_val(systolic_mult_0_send_val||produce_run),
    .recv_msg(memory_engine_out_1_recv_msg),
    .send_rdy(memory_engine_out_1_send_rdy),
    .send_val(memory_engine_out_1_send_val),
    .send_msg(memory_engine_out_1_send_msg)
);

endmodule


`endif /* TOP_WRAPPER_V */

`line 5 "tapeout/block_test/WrapperVRTL.v" 0
`line 1 "systolic_accelerator/msg_structs/wrapper_msg.v" 0
`ifndef WRAPPER_MSG_V
`define WRAPPER_MSG_V
`line 1 "systolic_accelerator/msg_structs/data_type.v" 0
`ifndef DATATYPE
`define DATATYPE
parameter INT_WIDTH = 8;
parameter FRAC_WIDTH = 8;
`endif /*DATATYPE*/
`line 4 "systolic_accelerator/msg_structs/wrapper_msg.v" 0
//========================================================================
// Memory Request Message
//========================================================================
// Memory request messages can either be for a read or write. Read
// requests include an opaque field, the address, and the number of bytes
// to read, while write requests include an opaque field, the address,
// the number of bytes to write, and the actual data to write.
//
// Message Format:
//
//    4b    p_opaque_nbits  p_addr_nbits       calc   p_data_nbits
//  +------+---------------+------------------+------+------------------+
//  | type | opaque        | addr             | len  | data             |
//  +------+---------------+------------------+------+------------------+
//
// The message type is parameterized by the number of bits in the opaque
// field, address field, and data field. Note that the size of the length
// field is caclulated from the number of bits in the data field, and
// that the length field is expressed in _bytes_. If the value of the
// length field is zero, then the read or write should be for the full
// width of the data field.
//
// For example, if the opaque field is 8 bits, the address is 32 bits and
// the data is also 32 bits, then the message format is as follows:
//
//   77  74 73           66 65              34 33  32 31               0
//  +------+---------------+------------------+------+------------------+
//  | type | opaque        | addr             | len  | data             |
//  +------+---------------+------------------+------+------------------+
//
// The length field is two bits. A length value of one means read or write
// a single byte, a length value of two means read or write two bytes, and
// so on. A length value of zero means read or write all four bytes. Note
// that not all memories will necessarily support any alignment and/or any
// value for the length field.
//
// The opaque field is reserved for use by a specific implementation. All
// memories should guarantee that every response includes the opaque
// field corresponding to the request that generated the response.

//------------------------------------------------------------------------
// Memory Request Struct: Using a packed struct to represent the message
//------------------------------------------------------------------------

parameter NUMCHIP = 4;
parameter DATA_ENTRIES = 2;
parameter DATA_LAT = 0;
parameter SYSTOLIC_SIZE = 2;
parameter SYSTOLIC_STEP_SIZE = DATA_ENTRIES;

typedef struct packed {
    logic [INT_WIDTH + FRAC_WIDTH - 1:0] data;
    logic [NUMCHIP-1:0] chip_select;
    logic mode;
    logic run;
    logic final_run;
} wrapper_recv_msg;

typedef struct packed {
    logic [INT_WIDTH + FRAC_WIDTH - 1:0] result_0;
    logic [INT_WIDTH + FRAC_WIDTH - 1:0] result_1;
} wrapper_send_msg;


`endif /* WRAPPER_MSG_V */

`line 6 "tapeout/block_test/WrapperVRTL.v" 0

module tapeout_block_test_WrapperVRTL
(
  input clk,
  input reset,

  input logic send_rdy, // TODO, need halt
  output logic send_val,
  output [(INT_WIDTH+FRAC_WIDTH)*2-1:0] send_msg,

  input logic recv_val,
  output logic recv_rdy,
  input [INT_WIDTH+FRAC_WIDTH+4+3-1:0] recv_msg // share by 4
);

Wrapper #
(
  DATA_ENTRIES,
  DATA_LAT,

  INT_WIDTH,
	FRAC_WIDTH,
  SYSTOLIC_SIZE,
  SYSTOLIC_STEP_SIZE
) wrapper
(
  .clk(clk),
  .reset(reset),
  .send_rdy(send_rdy),
  .send_val(send_val),
  .send_msg(send_msg),
  .recv_val(recv_val),
  .recv_rdy(recv_rdy),
  .recv_msg(recv_msg)
);

`ifndef SYNTHESIS

logic [`VC_TRACE_NBITS-1:0] str;
`VC_TRACE_BEGIN
begin

  // ''' LAB TASK ''''''''''''''''''''''''''''''''''''''''''''''''''''''
  // Define line trace here
  // '''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\/
  // $sformat( str, "wr:%b:%x:%x:%x:%x", recv_msg.chip_select, recv_msg.data, recv_msg.mode, recv_msg.run, recv_msg.final_run);
  // vc_trace.append_val_rdy_str( trace_str, recv_val, recv_rdy, str );
  // $sformat( str, " > " );
  // vc_trace.append_str( trace_str, str );
  // $sformat( str, "(" );
  // vc_trace.append_str( trace_str, str );
  // $sformat( str, "PE00:%x:%x:%x", wrapper.systolicMult.pe0.a, wrapper.systolicMult.pe0.b, wrapper.systolicMult.pe0.sum_result  );
  // vc_trace.append_str( trace_str, str );
  // $sformat( str, "|PE01:%x:%x:%x", wrapper.systolicMult.pe1.a, wrapper.systolicMult.pe1.b, wrapper.systolicMult.pe1.sum_result  );
  // vc_trace.append_str( trace_str, str );
  // $sformat( str, "|PE10:%x:%x:%x", wrapper.systolicMult.pe2.a, wrapper.systolicMult.pe2.b, wrapper.systolicMult.pe2.sum_result  );
  // vc_trace.append_str( trace_str, str );
  // $sformat( str, "|PE11:%x:%x:%x", wrapper.systolicMult.pe3.a, wrapper.systolicMult.pe3.b, wrapper.systolicMult.pe3.sum_result  );
  // vc_trace.append_str( trace_str, str );
  // $sformat( str, ") > " );
  // vc_trace.append_str( trace_str, str );
  // $sformat( str, "rd:%x:%x", send_msg.result_0, send_msg.result_1);
  // vc_trace.append_val_rdy_str( trace_str, send_val, send_rdy, str );

end
`VC_TRACE_END

`endif /* SYNTHESIS */


endmodule

`endif /* TOP_WRAPPERVRTL_V */

`line 15 "tapeout/SPI_TapeOutBlockVRTL.v" 0

module tapeout_SPI_TapeOutBlockVRTL
#(
    parameter nbits = 34, // the size of the val/rdy msg for the SPI Minion (includes the two flow control bits)
    parameter num_entries = 5
)(
    input  logic clk,
    input  logic reset,

    input  logic loopthrough_sel,
    output logic minion_parity,
    output logic adapter_parity,

    // SPI Minion Ifc
    input  logic sclk,
    input  logic cs,
    input  logic mosi,
    output logic miso
);

parameter packet_nbits = nbits - 2; //remove control flow bits

logic                    send_val;
logic [packet_nbits-1:0] send_msg;
logic                    send_rdy;

logic                    recv_val; 
logic [packet_nbits-1:0] recv_msg;
logic                    recv_rdy;

// wire                    systolic_out_val;
// wire  [31:0]            systolic_out_msg;
// wire                    systolic_out_rdy;

// We add two to nbits for the two SPI minion flow control bits 
SPI_v3_components_SPIstackVRTL #(nbits, num_entries) SPIstack
(
    .clk(clk),
    .reset(reset),
    .loopthrough_sel(loopthrough_sel),
    .minion_parity(minion_parity),
    .adapter_parity(adapter_parity),

    // SPI Minion Ifc
    .sclk(sclk),
    .cs(cs),
    .mosi(mosi),
    .miso(miso),

    // Send/Recv Ifc
    .send_val(send_val),
    .send_msg(send_msg),
    .send_rdy(send_rdy),

    .recv_val(recv_val), 
    .recv_msg(recv_msg), 
    .recv_rdy(recv_rdy)
);

//=============================================================================
// TAPEOUT TASK: Instantiate your module below and connect it to the SPI stack
//=============================================================================

// tapeout_block_test_WrapperVRTL #(packet_nbits) SystolicMult_SPI_Test
// SPI_v3_components_PacketDisassemblerVRTL 
// #(    
//     .nbits_in('d50),
//     .nbits_out('d32)
// ) 
// PacketAssembler
// (
//     .clk (clk),
//     .reset(reset),

//     .req_val(systolic_out_val),
//     .req_msg(systolic_out_msg),
//     .req_rdy(systolic_out_rdy),

//     .resp_val(recv_val),
//     .resp_rdy(recv_rdy),
//     .resp_msg(recv_msg)
// );


tapeout_block_test_WrapperVRTL  SystolicMult_SPI_Test
(
    .clk (clk),
    .reset(reset),
    
    // Send/Recv Ifc
    .send_val(recv_val),
    .send_msg(recv_msg),
    .send_rdy(recv_rdy),

    .recv_val(send_val), 
    .recv_msg(send_val ? send_msg:32'b0),  
    .recv_rdy(send_rdy)
);

endmodule
`endif /* SPI_TAPEOUTBLOCKVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder SPI_TapeOutBlockVRTL__nbits_32__num_entries_5
//-----------------------------------------------------------

`ifndef SPI_TAPEOUTBLOCKVRTL__NBITS_32__NUM_ENTRIES_5
`define SPI_TAPEOUTBLOCKVRTL__NBITS_32__NUM_ENTRIES_5

module grp_17_SPI_TapeOutBlockRTL_32bits_5entries
(
  output logic [1-1:0] adapter_parity ,
  input logic [1-1:0] clk ,
  input logic [1-1:0] loopthrough_sel ,
  output logic [1-1:0] minion_parity ,
  input logic [1-1:0] reset ,
  input logic [1-1:0] cs ,
  output logic [1-1:0] miso ,
  input logic [1-1:0] mosi ,
  input logic [1-1:0] sclk 
);
  tapeout_SPI_TapeOutBlockVRTL
  #(
    .nbits( 34 ),
    .num_entries( 5 )
  ) v
  (
    .adapter_parity( adapter_parity ),
    .clk( clk ),
    .loopthrough_sel( loopthrough_sel ),
    .minion_parity( minion_parity ),
    .reset( reset ),
    .cs( cs ),
    .miso( miso ),
    .mosi( mosi ),
    .sclk( sclk )
  );
endmodule

`endif /* SPI_TAPEOUTBLOCKVRTL__NBITS_32__NUM_ENTRIES_5 */

