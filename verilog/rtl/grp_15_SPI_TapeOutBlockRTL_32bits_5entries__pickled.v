//-------------------------------------------------------------------------
// grp_15_SPI_TapeOutBlockRTL_32bits_5entries.v
//-------------------------------------------------------------------------
// This file is generated by PyMTL yosys-SystemVerilog translation pass.

// PyMTL VerilogPlaceholder SPI_TapeOutBlockVRTL Definition
// Full name: SPI_TapeOutBlockVRTL__nbits_32__num_entries_5
// At /home/tdt46/ece5745/project-group15/sim/tapeout/SPI_TapeOutBlockRTL.py

//***********************************************************
// Pickled source file of placeholder SPI_TapeOutBlockVRTL__nbits_32__num_entries_5
//***********************************************************

//-----------------------------------------------------------
// Dependency of placeholder SPI_TapeOutBlockVRTL
//-----------------------------------------------------------

`ifndef SPI_TAPEOUTBLOCKVRTL
`define SPI_TAPEOUTBLOCKVRTL

// The source code below are included because they are specified
// as the v_libs Verilog placeholder option of component SPI_TapeOutBlockVRTL__nbits_32__num_entries_5.

// If you get a duplicated def error from files included below, please
// make sure they are included either through the v_libs option or the
// explicit `include statement in the Verilog source code -- if they
// appear in both then they will be included twice!


// End of all v_libs files for component SPI_TapeOutBlockVRTL__nbits_32__num_entries_5

`line 1 "tapeout/SPI_TapeOutBlockVRTL.v" 0
//===========================================
// SPI_TapeOutBlockVRTL
//===========================================

`line 1 "SPI_v3/components/SPIstackVRTL.v" 0
// ==========================================================================
// SPIstackVRTL.py
// ==========================================================================
// 
// Author: Jack Brzozowski
//     May 7, 2022

`line 1 "SPI_v3/components/LoopThroughVRTL.v" 0
// ==========================================================================
// LoopThroughVRTL.py
// ==========================================================================
// This module is meant to either loopback data to the the upstream module, 
// or pass data to the downstream module, depending on the select bit. 
// If sel = 1, no data is passed to the downstream block, it is simply 
// looped to the upstream.
// If sel = 0, this module essentially connects the upstream to the 
// downstream blocks.

// Author: Dilan Lakhani, Updated by Jack Brzozowski
//     February 25, 2022

module SPI_v3_components_LoopThroughVRTL 
#(
    parameter nbits = 32 // the size of the val/rdy msg
)(
    input logic clk,
    input logic reset,
    input logic sel,

    // upstream Minion Ifc
    input  logic             upstream_req_val, 
    input  logic [nbits-1:0] upstream_req_msg, 
    output logic             upstream_req_rdy, 

    output logic             upstream_resp_val,
    output logic [nbits-1:0] upstream_resp_msg,
    input  logic             upstream_resp_rdy,

    // downstream Master Ifc
    output logic             downstream_req_val, 
    output logic [nbits-1:0] downstream_req_msg, 
    input  logic             downstream_req_rdy, 

    input  logic             downstream_resp_val,
    input  logic [nbits-1:0] downstream_resp_msg,
    output logic             downstream_resp_rdy
);

    assign upstream_resp_val= (sel) ? upstream_req_val : downstream_resp_val;
    assign upstream_resp_msg= (sel) ? upstream_req_msg : downstream_resp_msg;

    assign downstream_req_val= (sel) ? 0 : upstream_req_val;
    assign downstream_req_msg= upstream_req_msg;

    assign upstream_req_rdy= (sel) ? upstream_resp_rdy : downstream_req_rdy;

    assign downstream_resp_rdy= (sel) ? 0 : upstream_resp_rdy;

endmodule
`line 9 "SPI_v3/components/SPIstackVRTL.v" 0
`line 1 "SPI_v3/components/SPIMinionAdapterCompositeVRTL.v" 0
//-------------------------------------------------------------------------
// SPIMinionAdapterCompositeVRTL.v
//-------------------------------------------------------------------------
`line 1 "SPI_v3/components/SPIMinionVRTL.v" 0
//==========================================================================
//SPIMinionVRTL.v
//==========================================================================

`line 1 "SPI_v3/components/ShiftReg.v" 0
/*
==========================================================================
ShiftReg.v
==========================================================================
N-bit shift register.
*/

module ShiftReg
#(
    parameter nbits = 8
)
(
  input  logic             clk,
  input  logic             in_,
  input  logic [nbits-1:0] load_data,
  input  logic             load_en,
  output logic [nbits-1:0] out,
  input  logic             reset,
  input  logic             shift_en 
);
  
  always_ff @(posedge clk) 
  begin 
    if ( reset ) begin
      out <= { nbits{1'b0}};
    end
    else if ( load_en ) begin
      out <= load_data;
    end
    else if ( ( ~load_en ) & shift_en ) begin
      out <= { out[nbits-2:0], in_ };
    end
  end

endmodule
`line 6 "SPI_v3/components/SPIMinionVRTL.v" 0
`line 1 "SPI_v3/components/Synchronizer.v" 0
/*
==========================================================================
Synchronizer.v
==========================================================================
 - RTL code for the Synchronizer module.
 - It samples the input signal using the device clock and also detects
     positive and negative edges.
 - Reference: https://www.fpga4fun.com/SPI2.html
*/

module Synchronizer 
#(
    parameter reset_value = 1'b0
)(
  input  logic clk ,
  input  logic in_,
  output logic negedge_,
  output logic out,
  output logic posedge_,
  input  logic reset 
);

  logic [2:0] shreg;
  
  always_comb begin
    negedge_ = shreg[2] & ( ~shreg[1] );
    posedge_ = ( ~shreg[2] ) & shreg[1];
  end
  
  always_ff @(posedge clk) begin
    if ( reset ) begin
      shreg <= { 3{reset_value} };
    end
    else
      shreg <= { shreg[1:0], in_ };
  end

  assign out = shreg[1];

endmodule
`line 7 "SPI_v3/components/SPIMinionVRTL.v" 0

module SPI_v3_components_SPIMinionVRTL
#(
  parameter nbits = 8
)
(
  input  logic             clk,
  input  logic             cs,
  output logic             miso,
  input  logic             mosi,
  input  logic             reset,
  input  logic             sclk,
  output logic             pull_en,
  input  logic [nbits-1:0] pull_msg,
  output logic             push_en,
  output logic [nbits-1:0] push_msg,  
  output logic             parity
);
  //-------------------------------------------------------------
  // Component cs_sync
  //-------------------------------------------------------------

  logic cs_sync_clk;
  logic cs_sync_in_;
  logic cs_sync_negedge_;
  logic cs_sync_out;
  logic cs_sync_posedge_;
  logic cs_sync_reset;

  Synchronizer #(1'b1) cs_sync
  (
    .clk( cs_sync_clk ),
    .in_( cs_sync_in_ ),
    .negedge_( cs_sync_negedge_ ),
    .out( cs_sync_out ),
    .posedge_( cs_sync_posedge_ ),
    .reset( cs_sync_reset )
  );

  //-------------------------------------------------------------
  // Component mosi_sync
  //-------------------------------------------------------------

  logic mosi_sync_clk;
  logic mosi_sync_in_;
  logic mosi_sync_negedge_;
  logic mosi_sync_out;
  logic mosi_sync_posedge_;
  logic mosi_sync_reset;

  Synchronizer #(1'b0) mosi_sync
  (
    .clk( mosi_sync_clk ),
    .in_( mosi_sync_in_ ),
    .negedge_( mosi_sync_negedge_ ),
    .out( mosi_sync_out ),
    .posedge_( mosi_sync_posedge_ ),
    .reset( mosi_sync_reset )
  );

  //-------------------------------------------------------------
  // Component sclk_sync
  //-------------------------------------------------------------

  logic sclk_sync_clk;
  logic sclk_sync_in_;
  logic sclk_sync_negedge_;
  logic sclk_sync_out;
  logic sclk_sync_posedge_;
  logic sclk_sync_reset;

  Synchronizer #(1'b0) sclk_sync
  (
    .clk( sclk_sync_clk ),
    .in_( sclk_sync_in_ ),
    .negedge_( sclk_sync_negedge_ ),
    .out( sclk_sync_out ),
    .posedge_( sclk_sync_posedge_ ),
    .reset( sclk_sync_reset )
  );

  //-------------------------------------------------------------
  // Component shreg_in
  //-------------------------------------------------------------

  logic             shreg_in_clk;
  logic             shreg_in_in_;
  logic [nbits-1:0] shreg_in_load_data;
  logic             shreg_in_load_en;
  logic [nbits-1:0] shreg_in_out;
  logic             shreg_in_reset;
  logic             shreg_in_shift_en;

  ShiftReg #( nbits ) shreg_in
  (
    .clk( shreg_in_clk ),
    .in_( shreg_in_in_ ),
    .load_data( shreg_in_load_data ),
    .load_en( shreg_in_load_en ),
    .out( shreg_in_out ),
    .reset( shreg_in_reset ),
    .shift_en( shreg_in_shift_en )
  );

  //-------------------------------------------------------------
  // Component shreg_out
  //-------------------------------------------------------------

  logic             shreg_out_clk;
  logic             shreg_out_in_;
  logic [nbits-1:0] shreg_out_load_data;
  logic             shreg_out_load_en;
  logic [nbits-1:0] shreg_out_out;
  logic             shreg_out_reset;
  logic             shreg_out_shift_en;

  ShiftReg #( nbits ) shreg_out
  (
    .clk( shreg_out_clk ),
    .in_( shreg_out_in_ ),
    .load_data( shreg_out_load_data ),
    .load_en( shreg_out_load_en ),
    .out( shreg_out_out ),
    .reset( shreg_out_reset ),
    .shift_en( shreg_out_shift_en )
  );
  
  always_comb begin
    shreg_in_shift_en = ( ~cs_sync_out ) & sclk_sync_posedge_;
    shreg_out_shift_en = ( ~cs_sync_out ) & sclk_sync_negedge_;
  end

  assign cs_sync_clk         = clk;
  assign cs_sync_reset       = reset;
  assign cs_sync_in_         = cs;
  assign sclk_sync_clk       = clk;
  assign sclk_sync_reset     = reset;
  assign sclk_sync_in_       = sclk;
  assign mosi_sync_clk       = clk;
  assign mosi_sync_reset     = reset;
  assign mosi_sync_in_       = mosi;
  assign shreg_in_clk        = clk;
  assign shreg_in_reset      = reset;
  assign shreg_in_in_        = mosi_sync_out;
  assign shreg_in_load_en    = 1'b0;
  assign shreg_in_load_data  = {nbits{1'b0}};
  assign shreg_out_clk       = clk;
  assign shreg_out_reset     = reset;
  assign shreg_out_in_       = 1'b0;
  assign shreg_out_load_en   = pull_en;
  assign shreg_out_load_data = pull_msg;
  assign miso                = shreg_out_out[nbits-1];
  assign pull_en             = cs_sync_negedge_;
  assign push_en             = cs_sync_posedge_;
  assign push_msg            = shreg_in_out;
  assign parity              = (^push_msg[nbits-3:0]) & push_en;

endmodule

`line 5 "SPI_v3/components/SPIMinionAdapterCompositeVRTL.v" 0
`line 1 "SPI_v3/components/SPIMinionAdapterVRTL.v" 0
//-------------------------------------------------------------------------
// SPIMinionAdapterVRTL.v
//-------------------------------------------------------------------------
`line 1 "vc/queues.v" 0
//========================================================================
// Verilog Components: Queues
//========================================================================

`ifndef VC_QUEUES_V
`define VC_QUEUES_V

`line 1 "vc/regs.v" 0
//========================================================================
// Verilog Components: Registers
//========================================================================

// Note that we place the register output earlier in the port list since
// this is one place we might actually want to use positional port
// binding like this:
//
//  logic [p_nbits-1:0] result_B;
//  vc_Reg#(p_nbits) result_AB( clk, result_B, result_A );

`ifndef VC_REGS_V
`define VC_REGS_V

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop
//------------------------------------------------------------------------

module vc_Reg
#(
  parameter p_nbits = 1
)(
  input  logic               clk, // Clock input
  output logic [p_nbits-1:0] q,   // Data output
  input  logic [p_nbits-1:0] d    // Data input
);

  always_ff @( posedge clk )
    q <= d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with reset
//------------------------------------------------------------------------

module vc_ResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d      // Data input
);

  always_ff @( posedge clk )
    q <= reset ? p_reset_value : d;

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable
//------------------------------------------------------------------------

module vc_EnReg
#(
  parameter p_nbits = 1
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( en )
      q <= d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

//------------------------------------------------------------------------
// Postive-edge triggered flip-flop with enable and reset
//------------------------------------------------------------------------

module vc_EnResetReg
#(
  parameter p_nbits       = 1,
  parameter p_reset_value = 0
)(
  input  logic               clk,   // Clock input
  input  logic               reset, // Sync reset input
  output logic [p_nbits-1:0] q,     // Data output
  input  logic [p_nbits-1:0] d,     // Data input
  input  logic               en     // Enable input
);

  always_ff @( posedge clk )
    if ( reset || en )
      q <= reset ? p_reset_value : d;

  // Assertions

  `ifndef SYNTHESIS

  /*
  always_ff @( posedge clk )
    if ( !reset )
      `VC_ASSERT_NOT_X( en );
  */

  `endif /* SYNTHESIS */

endmodule

`endif /* VC_REGS_V */


`line 9 "vc/queues.v" 0
`line 1 "vc/muxes.v" 0
//========================================================================
// Verilog Components: Muxes
//========================================================================

`ifndef VC_MUXES_V
`define VC_MUXES_V

//------------------------------------------------------------------------
// 2 Input Mux
//------------------------------------------------------------------------

module vc_Mux2
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1,
  input  logic               sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      1'd0 : out = in0;
      1'd1 : out = in1;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 3 Input Mux
//------------------------------------------------------------------------

module vc_Mux3
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 4 Input Mux
//------------------------------------------------------------------------

module vc_Mux4
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3,
  input  logic         [1:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      2'd0 : out = in0;
      2'd1 : out = in1;
      2'd2 : out = in2;
      2'd3 : out = in3;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 5 Input Mux
//------------------------------------------------------------------------

module vc_Mux5
#(
 parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 6 Input Mux
//------------------------------------------------------------------------

module vc_Mux6
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 7 Input Mux
//------------------------------------------------------------------------

module vc_Mux7
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// 8 Input Mux
//------------------------------------------------------------------------

module vc_Mux8
#(
  parameter p_nbits = 1
)(
  input  logic [p_nbits-1:0] in0, in1, in2, in3, in4, in5, in6, in7,
  input  logic         [2:0] sel,
  output logic [p_nbits-1:0] out
);

  always_comb
  begin
    case ( sel )
      3'd0 : out = in0;
      3'd1 : out = in1;
      3'd2 : out = in2;
      3'd3 : out = in3;
      3'd4 : out = in4;
      3'd5 : out = in5;
      3'd6 : out = in6;
      3'd7 : out = in7;
      default : out = {p_nbits{1'bx}};
    endcase
  end

endmodule

//------------------------------------------------------------------------
// N Input Mux
//------------------------------------------------------------------------

module vc_MuxN
#(
  parameter p_nbits = 1,
  parameter p_ninputs = 2
)(
  input  logic [p_ninputs-1:0][p_nbits-1:0] in,
  input  logic [$clog2(p_ninputs)-1:0]      sel,
  output logic [p_nbits-1:0]                out
);

  assign out = in[sel];

endmodule

`endif /* VC_MUXES_V */


`line 10 "vc/queues.v" 0
`line 1 "vc/regfiles.v" 0
//========================================================================
// Verilog Components: Register Files
//========================================================================

`ifndef VC_REGFILES_V
`define VC_REGFILES_V

//------------------------------------------------------------------------
// 1r1w register file
//------------------------------------------------------------------------

module vc_Regfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 1r1w register file with reset
//------------------------------------------------------------------------

module vc_ResetRegfile_1r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,
  parameter p_reset_value = 0,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr,
  output logic [p_data_nbits-1:0] read_data,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data = rfile[read_addr];

  // Write on positive clock edge. We have to use a generate statement to
  // allow us to include the reset logic for each individual register.

  genvar i;
  generate
    for ( i = 0; i < p_num_entries; i = i+1 )
    begin : wport
      always_ff @( posedge clk )
        if ( reset )
          rfile[i] <= p_reset_value;
        else if ( write_en && (i[c_addr_nbits-1:0] == write_addr) )
          rfile[i] <= write_data;
    end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r1w register file
//------------------------------------------------------------------------

module vc_Regfile_2r1w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                   clk,
  input  logic                   reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [p_data_nbits-1:0] write_data
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk )
    if ( write_en )
      rfile[write_addr] <= write_data;

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en ) begin
        `VC_ASSERT_NOT_X( write_addr );
        `VC_ASSERT( write_addr < p_num_entries );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// 2r2w register file
//------------------------------------------------------------------------

module vc_Regfile_2r2w
#(
  parameter p_data_nbits  = 1,
  parameter p_num_entries = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits  = $clog2(p_num_entries)
)(
  input  logic                    clk,
  input  logic                    reset,

  // Read port 0 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr0,
  output logic [p_data_nbits-1:0] read_data0,

  // Read port 1 (combinational read)

  input  logic [c_addr_nbits-1:0] read_addr1,
  output logic [p_data_nbits-1:0] read_data1,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en0,
  input  logic [c_addr_nbits-1:0] write_addr0,
  input  logic [p_data_nbits-1:0] write_data0,

  // Write port (sampled on the rising clock edge)

  input  logic                    write_en1,
  input  logic [c_addr_nbits-1:0] write_addr1,
  input  logic [p_data_nbits-1:0] write_data1
);

  logic [p_data_nbits-1:0] rfile[p_num_entries-1:0];

  // Combinational read

  assign read_data0 = rfile[read_addr0];
  assign read_data1 = rfile[read_addr1];

  // Write on positive clock edge

  always_ff @( posedge clk ) begin

    if ( write_en0 )
      rfile[write_addr0] <= write_data0;

    if ( write_en1 )
      rfile[write_addr1] <= write_data1;

  end

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( write_en0 );
      `VC_ASSERT_NOT_X( write_en1 );

      // If write_en is one, then write address better be less than the
      // number of entries and definitely cannot be X's.

      if ( write_en0 ) begin
        `VC_ASSERT_NOT_X( write_addr0 );
        `VC_ASSERT( write_addr0 < p_num_entries );
      end

      if ( write_en1 ) begin
        `VC_ASSERT_NOT_X( write_addr1 );
        `VC_ASSERT( write_addr1 < p_num_entries );
      end

      // It is invalid to use the same write address for both write ports

      if ( write_en0 && write_en1 ) begin
        `VC_ASSERT( write_addr0 != write_addr1 );
      end

    end
  end
  */

endmodule

//------------------------------------------------------------------------
// Register file specialized for r0 == 0
//------------------------------------------------------------------------

module vc_Regfile_2r1w_zero
(
  input  logic        clk,
  input  logic        reset,

  input  logic  [4:0] rd_addr0,
  output logic [31:0] rd_data0,

  input  logic  [4:0] rd_addr1,
  output logic [31:0] rd_data1,

  input  logic        wr_en,
  input  logic  [4:0] wr_addr,
  input  logic [31:0] wr_data
);

  // these wires are to be hooked up to the actual register file read
  // ports

  logic [31:0] rf_read_data0;
  logic [31:0] rf_read_data1;

  vc_Regfile_2r1w
  #(
    .p_data_nbits  (32),
    .p_num_entries (32)
  )
  rfile
  (
    .clk         (clk),
    .reset       (reset),
    .read_addr0  (rd_addr0),
    .read_data0  (rf_read_data0),
    .read_addr1  (rd_addr1),
    .read_data1  (rf_read_data1),
    .write_en    (wr_en),
    .write_addr  (wr_addr),
    .write_data  (wr_data)
  );

  // we pick 0 value when either read address is 0
  assign rd_data0 = ( rd_addr0 == 5'd0 ) ? 32'd0 : rf_read_data0;
  assign rd_data1 = ( rd_addr1 == 5'd0 ) ? 32'd0 : rf_read_data1;

endmodule

`endif /* VC_REGFILES_V */


`line 11 "vc/queues.v" 0
`line 1 "vc/trace.v" 0
//========================================================================
// Line Tracing
//========================================================================

`ifndef VC_TRACE_V
`define VC_TRACE_V

// NOTE: This macro is declared outside of the module to allow some vc
// modules to see it and use it in their own params. Verilog does not
// allow other modules to hierarchically reference the nbits localparam
// inside this module in constant expressions (e.g., localparams).

`define VC_TRACE_NCHARS 512
`define VC_TRACE_NBITS  512*8

`ifndef SYNTHESIS

module vc_Trace
(
  input logic clk,
  input logic reset
);

  integer len0;
  integer len1;
  integer idx0;
  integer idx1;

  // NOTE: If you change these, then you also need to change the
  // hard-coded constant in the declaration of the trace function at the
  // bottom of this file.
  // NOTE: You would also need to change the VC_TRACE_NBITS and
  // VC_TRACE_NCHARS macro at the top of this file.

  localparam nchars = 512;
  localparam nbits  = 512*8;

  // This is the actual trace storage used when displaying a trace

  logic [nbits-1:0] storage;

  // Meant to be accesible from outside module

  integer cycles_next = 0;
  integer cycles      = 0;

  // Get trace level from command line

  logic [3:0] level;

`ifndef VERILATOR
  initial begin
    if ( !$value$plusargs( "trace=%d", level ) ) begin
      level = 0;
    end
  end
`else
  initial begin
    level = 1;
  end
`endif // !`ifndef VERILATOR

  // Track cycle count

  always_ff @( posedge clk ) begin
    cycles <= ( reset ) ? 0 : cycles_next;
  end

  //----------------------------------------------------------------------
  // append_str
  //----------------------------------------------------------------------
  // Appends a string to the trace.

  task append_str
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    len0 = 1;
    while ( str[len0*8+:8] != 0 ) begin
      len0 = len0 + 1;
    end

    idx0 = trace[31:0];

    for ( idx1 = len0-1; idx1 >= 0; idx1 = idx1 - 1 )
    begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8 +: 8 ];
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_str_ljust
  //----------------------------------------------------------------------
  // Appends a left-justified string to the trace.

  task append_str_ljust
  (
    inout logic [nbits-1:0] trace,
    input logic [nbits-1:0] str
  );
  begin

    idx0 = trace[31:0];
    idx1 = nchars;

    while ( str[ idx1*8-1 -: 8 ] != 0 ) begin
      trace[ idx0*8 +: 8 ] = str[ idx1*8-1 -: 8 ];
      idx0 = idx0 - 1;
      idx1 = idx1 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_chars
  //----------------------------------------------------------------------
  // Appends the given number of characters to the trace.

  task append_chars
  (
    inout logic   [nbits-1:0] trace,
    input logic         [7:0] char,
    input integer             num
  );
  begin

    idx0 = trace[31:0];

    for ( idx1 = 0;
          idx1 < num;
          idx1 = idx1 + 1 )
    begin
      trace[idx0*8+:8] = char;
      idx0 = idx0 - 1;
    end

    trace[31:0] = idx0;

  end
  endtask

  //----------------------------------------------------------------------
  // append_val_str
  //----------------------------------------------------------------------
  // Append a string modified by val signal.

  task append_val_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val )
      append_str( trace, str );
    else if ( !val )
      append_chars( trace, " ", len1 );
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

  //----------------------------------------------------------------------
  // val_rdy_str
  //----------------------------------------------------------------------
  // Append a string modified by val/rdy signals.

  task append_val_rdy_str
  (
    inout logic [nbits-1:0] trace,
    input logic             val,
    input logic             rdy,
    input logic [nbits-1:0] str
  );
  begin

    len1 = 0;
    while ( str[len1*8+:8] != 0 ) begin
      len1 = len1 + 1;
    end

    if ( val & rdy ) begin
      append_str( trace, str );
    end
    else if ( rdy && !val ) begin
      append_chars( trace, " ", len1 );
    end
    else if ( !rdy && !val ) begin
      append_str( trace, "." );
      append_chars( trace, " ", len1-1 );
    end
    else if ( !rdy && val ) begin
      append_str( trace, "#" );
      append_chars( trace, " ", len1-1 );
    end
    else begin
      append_str( trace, "x" );
      append_chars( trace, " ", len1-1 );
    end

  end
  endtask

endmodule

`endif /* SYNTHESIS */

//------------------------------------------------------------------------
// VC_TRACE_NBITS_TO_NCHARS
//------------------------------------------------------------------------
// Macro to determine number of characters for a net

`define VC_TRACE_NBITS_TO_NCHARS( nbits_ ) ((nbits_+3)/4)

//------------------------------------------------------------------------
// VC_TRACE_BEGIN
//------------------------------------------------------------------------

//`define VC_TRACE_BEGIN                                                  \
//  export "DPI-C" task line_trace;                                       \
//  vc_Trace vc_trace(clk,reset);                                         \
//  task line_trace( inout bit [(512*8)-1:0] trace_str );

`ifndef VERILATOR
`define VC_TRACE_BEGIN                                                  \
  vc_Trace vc_trace(clk,reset);                                         \
                                                                        \
  task display_trace;                                                   \
  begin                                                                 \
                                                                        \
    if ( vc_trace.level > 0 ) begin                                     \
      vc_trace.storage[15:0] = vc_trace.nchars-1;                       \
                                                                        \
      line_trace( vc_trace.storage );                                   \
                                                                        \
      $write( "%4d: ", vc_trace.cycles );                               \
                                                                        \
      vc_trace.idx0 = vc_trace.storage[15:0];                           \
      for ( vc_trace.idx1 = vc_trace.nchars-1;                          \
            vc_trace.idx1 > vc_trace.idx0;                              \
            vc_trace.idx1 = vc_trace.idx1 - 1 )                         \
      begin                                                             \
        $write( "%s", vc_trace.storage[vc_trace.idx1*8+:8] );           \
      end                                                               \
      $write("\n");                                                     \
                                                                        \
    end                                                                 \
                                                                        \
    vc_trace.cycles_next = vc_trace.cycles + 1;                         \
                                                                        \
  end                                                                   \
  endtask                                                               \
                                                                        \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`else
`define VC_TRACE_BEGIN                                                  \
  export "DPI-C" task line_trace;                                       \
  vc_Trace vc_trace(clk,reset);                                         \
  task line_trace( inout bit [(512*8)-1:0] trace_str );
`endif

//------------------------------------------------------------------------
// VC_TRACE_END
//------------------------------------------------------------------------

`define VC_TRACE_END \
  endtask

`endif /* VC_TRACE_V */


`line 12 "vc/queues.v" 0

//------------------------------------------------------------------------
// Defines
//------------------------------------------------------------------------

`define VC_QUEUE_NORMAL   4'b0000
`define VC_QUEUE_PIPE     4'b0001
`define VC_QUEUE_BYPASS   4'b0010

//------------------------------------------------------------------------
// Single-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a single-elment queue. It is designed to
// be attached to a storage element with a write enable. Additionally, it
// includes the ability to statically enable pipeline and/or bypass
// behavior. Pipeline behavior is when the deq_rdy signal is
// combinationally wired to the enq_rdy signal allowing elements to be
// dequeued and enqueued in the same cycle when the queue is full. Bypass
// behavior is when the enq_en signal is combinationally wired to the
// deq_rdy signal allowing elements to bypass the storage element if the
// storage element is empty.

module vc_QueueCtrl1
#(
  parameter p_type = `VC_QUEUE_NORMAL
)(
  input  logic clk,
  input  logic reset,

  input  logic recv_val,        // Enqueue data is valid
  output logic recv_rdy,        // Ready for producer to do an enqueue

  output logic send_val,         // Dequeue is called
  input  logic send_rdy,        // Consumer is ready to do a dequeue

  output logic write_en,       // Write en signal to wire up to storage element
  output logic bypass_mux_sel, // Used to control bypass mux for bypass queues
  output logic num_free_entries // Either zero or one
);

  // Status register

  logic full;
  logic full_next;

  always_ff @(posedge clk) begin
    full <= reset ? 1'b0 : full_next;
  end

  assign num_free_entries = full ? 1'b0 : 1'b1;

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when the call is enabled

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full;

  logic  do_pipe;
  assign do_pipe = c_pipe_en   && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the deq_val signal is also calculated combinationally
  // from the enq_val signal.

  assign recv_rdy  = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val  = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the full register input

  assign full_next = ( do_deq && ~do_pipe )   ? 1'b0
                   : ( do_enq && ~do_bypass ) ? 1'b1
                   :                            full;

endmodule

//------------------------------------------------------------------------
// Single-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for single element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath1
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1
)(
  input  logic                   clk,
  input  logic                   reset,
  input  logic                   write_en,
  input  logic                   bypass_mux_sel,
  input  logic [p_msg_nbits-1:0] recv_msg,
  output logic [p_msg_nbits-1:0] send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] qstore;

  vc_EnReg#(p_msg_nbits) qstore_reg
  (
    .clk   (clk),
    .reset (reset),
    .en    (write_en),
    .d     (recv_msg),
    .q     (qstore)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (qstore),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = qstore;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Control Logic
//------------------------------------------------------------------------
// This is the control logic for a multi-elment queue. It is designed to
// be attached to a Regfile storage element. Additionally, it includes
// the ability to statically enable pipeline and/or bypass behavior.
// Pipeline behavior is when the send_rdy signal is combinationally wired
// to the recv_rdy signal allowing elements to be dequeued and enqueued in
// the same cycle when the queue is full. Bypass behavior is when the
// recv_val signal is cominationally wired to the send_val signal allowing
// elements to bypass the storage element if the storage element is
// empty.

module vc_QueueCtrl
#(
  parameter p_type     = `VC_QUEUE_NORMAL,
  parameter p_num_msgs = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk, reset,

  input  logic                    recv_val,        // Enqueue is valid
  output logic                    recv_rdy,        // Ready for producer to enqueue

  output logic                    send_val,        // Dequeue is called
  input  logic                    send_rdy,        // Consumer is ready to dequeue

  output logic                    write_en,       // Wen to wire to regfile
  output logic [c_addr_nbits-1:0] write_addr,     // Waddr to wire to regfile
  output logic [c_addr_nbits-1:0] read_addr,      // Raddr to wire to regfile
  output logic                    bypass_mux_sel, // Control mux for bypass queues
  output logic [c_addr_nbits:0]   num_free_entries // Num of free entries in queue
);

  // Enqueue and dequeue pointers

  logic [c_addr_nbits-1:0] enq_ptr;
  logic [c_addr_nbits-1:0] enq_ptr_next;

  vc_ResetReg#(c_addr_nbits) enq_ptr_reg
  (
    .clk     (clk),
    .reset   (reset),
    .d       (enq_ptr_next),
    .q       (enq_ptr)
  );

  logic [c_addr_nbits-1:0] deq_ptr;
  logic [c_addr_nbits-1:0] deq_ptr_next;

  vc_ResetReg#(c_addr_nbits) deq_ptr_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (deq_ptr_next),
    .q     (deq_ptr)
  );

  assign write_addr = enq_ptr;
  assign read_addr  = deq_ptr;

  // Extra state to tell difference between full and empty

  logic full;
  logic full_next;

  vc_ResetReg#(1) full_reg
  (
    .clk   (clk),
    .reset (reset),
    .d     (full_next),
    .q     (full)
  );

  // Determine if pipeline or bypass behavior is enabled

  localparam c_pipe_en   = |( p_type & `VC_QUEUE_PIPE   );
  localparam c_bypass_en = |( p_type & `VC_QUEUE_BYPASS );

  // We enq/deq only when they are both ready and valid

  logic  do_enq;
  assign do_enq = recv_rdy && recv_val;

  logic  do_deq;
  assign do_deq = send_rdy && send_val;

  // Determine if we have pipeline or bypass behaviour and
  // set the write enable accordingly.

  logic  empty;
  assign empty = ~full && (enq_ptr == deq_ptr);

  logic  do_pipe;
  assign do_pipe = c_pipe_en && full  && do_enq && do_deq;

  logic  do_bypass;
  assign do_bypass = c_bypass_en && empty && do_enq && do_deq;

  assign write_en = do_enq && ~do_bypass;

  // Regardless of the type of queue or whether or not we are actually
  // doing a bypass, if the queue is empty then we select the enq bits,
  // otherwise we select the output of the queue state elements.

  assign bypass_mux_sel = empty;

  // Ready signals are calculated from full register. If pipeline
  // behavior is enabled, then the recv_rdy signal is also calculated
  // combinationally from the send_rdy signal. If bypass behavior is
  // enabled then the send_val signal is also calculated combinationally
  // from the recv_val signal.

  assign recv_rdy = ~full  || ( c_pipe_en   && full  && send_rdy );
  assign send_val = ~empty || ( c_bypass_en && empty && recv_val );

  // Control logic for the enq/deq pointers and full register

  logic [c_addr_nbits-1:0] deq_ptr_plus1;
  assign deq_ptr_plus1 = deq_ptr + 1'b1;

  /* verilator lint_off WIDTH */

  logic [c_addr_nbits-1:0] deq_ptr_inc;
  assign deq_ptr_inc = (deq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : deq_ptr_plus1;

  logic [c_addr_nbits-1:0] enq_ptr_plus1;
  assign enq_ptr_plus1 = enq_ptr + 1'b1;

  logic [c_addr_nbits-1:0] enq_ptr_inc;
  assign enq_ptr_inc = (enq_ptr_plus1 == p_num_msgs) ? {c_addr_nbits{1'b0}} : enq_ptr_plus1;

  /* verilator lint_on WIDTH */

  assign deq_ptr_next
    = ( do_deq && ~do_bypass ) ? ( deq_ptr_inc ) : deq_ptr;

  assign enq_ptr_next
    = ( do_enq && ~do_bypass ) ? ( enq_ptr_inc ) : enq_ptr;

  assign full_next
    = ( do_enq && ~do_deq && ( enq_ptr_inc == deq_ptr ) ) ? 1'b1
    : ( do_deq && full && ~do_pipe )                      ? 1'b0
    :                                                       full;

  // Number of free entries

  assign num_free_entries
    = full                ? {(c_addr_nbits+1){1'b0}}
    : empty               ? p_num_msgs[c_addr_nbits:0]
    : (enq_ptr > deq_ptr) ? p_num_msgs[c_addr_nbits:0] - (enq_ptr - deq_ptr)
    : (deq_ptr > enq_ptr) ? deq_ptr - enq_ptr
    :                       {(c_addr_nbits+1){1'bx}};

endmodule

//------------------------------------------------------------------------
// Multi-Element Queue Datapath
//------------------------------------------------------------------------
// This is the datpath for multi-element queues. It includes a register
// and a bypass mux if needed.

module vc_QueueDpath
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 4,
  parameter p_num_msgs  = 2,

  // Local constants not meant to be set from outside the module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    write_en,
  input  logic                    bypass_mux_sel,
  input  logic [c_addr_nbits-1:0] write_addr,
  input  logic [c_addr_nbits-1:0] read_addr,
  input  logic [p_msg_nbits-1:0]  recv_msg,
  output logic [p_msg_nbits-1:0]  send_msg
);

  // Queue storage

  logic [p_msg_nbits-1:0] read_data;

  vc_Regfile_1r1w#(p_msg_nbits,p_num_msgs) qstore
  (
    .clk        (clk),
    .reset      (reset),
    .read_addr  (read_addr),
    .read_data  (read_data),
    .write_en   (write_en),
    .write_addr (write_addr),
    .write_data (recv_msg)
  );

  // Bypass muxing

  generate
  if ( |(p_type & `VC_QUEUE_BYPASS ) )

    vc_Mux2#(p_msg_nbits) bypass_mux
    (
      .in0 (read_data),
      .in1 (recv_msg),
      .sel (bypass_mux_sel),
      .out (send_msg)
    );

  else
    assign send_msg = read_data;
  endgenerate

endmodule

//------------------------------------------------------------------------
// Queue
//------------------------------------------------------------------------

module vc_Queue
#(
  parameter p_type      = `VC_QUEUE_NORMAL,
  parameter p_msg_nbits = 1,
  parameter p_num_msgs  = 2,

  // parameters not meant to be set outside this module
  parameter c_addr_nbits = $clog2(p_num_msgs)
)(
  input  logic                   clk,
  input  logic                   reset,

  input  logic                   recv_val,
  output logic                   recv_rdy,
  input  logic [p_msg_nbits-1:0] recv_msg,

  output logic                   send_val,
  input  logic                   send_rdy,
  output logic [p_msg_nbits-1:0] send_msg,

  output logic [c_addr_nbits:0]  num_free_entries
);


  generate
  if ( p_num_msgs == 1 )
  begin

    logic write_en;
    logic bypass_mux_sel;

    vc_QueueCtrl1#(p_type) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath1#(p_type,p_msg_nbits) dpath
    (
      .clk            (clk),
      .reset          (reset),
      .write_en       (write_en),
      .bypass_mux_sel (bypass_mux_sel),
      .recv_msg       (recv_msg),
      .send_msg       (send_msg)
    );

  end
  else
  begin

    logic                    write_en;
    logic                    bypass_mux_sel;
    logic [c_addr_nbits-1:0] write_addr;
    logic [c_addr_nbits-1:0] read_addr;

    vc_QueueCtrl#(p_type,p_num_msgs) ctrl
    (
      .clk              (clk),
      .reset            (reset),
      .recv_val         (recv_val),
      .recv_rdy         (recv_rdy),
      .send_val         (send_val),
      .send_rdy         (send_rdy),
      .write_en         (write_en),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .bypass_mux_sel   (bypass_mux_sel),
      .num_free_entries (num_free_entries)
    );

    vc_QueueDpath#(p_type,p_msg_nbits,p_num_msgs) dpath
    (
      .clk              (clk),
      .reset            (reset),
      .write_en         (write_en),
      .bypass_mux_sel   (bypass_mux_sel),
      .write_addr       (write_addr),
      .read_addr        (read_addr),
      .recv_msg         (recv_msg),
      .send_msg         (send_msg)
    );

  end
  endgenerate

  // Assertions

  /*
  always_ff @( posedge clk ) begin
    if ( !reset ) begin
      `VC_ASSERT_NOT_X( enq_en  );
      `VC_ASSERT_NOT_X( enq_rdy );
      `VC_ASSERT_NOT_X( deq_en  );
      `VC_ASSERT_NOT_X( deq_rdy );
    end
  end
  */

  // Line Tracing

  //  logic [`VC_TRACE_NBITS_TO_NCHARS(p_msg_nbits)*8-1:0] str;
  //
  //  `VC_TRACE_BEGIN
  //  begin
  //
  //    $sformat( str, "%x", enq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, enq_en, enq_rdy, str );
  //
  //    vc_trace.append_str( trace_str, "(" );
  //    $sformat( str, "%x", p_num_msgs-num_free_entries );
  //    vc_trace.append_str( trace_str, str );
  //    vc_trace.append_str( trace_str, ")" );
  //
  //    $sformat( str, "%x", deq_msg );
  //    vc_trace.append_en_rdy_str( trace_str, deq_en, deq_rdy, str );

  // end
  // endtask

endmodule

`endif /* VC_QUEUES_V */


`line 5 "SPI_v3/components/SPIMinionAdapterVRTL.v" 0

module SPI_v3_components_SPIMinionAdapterVRTL
#(
  parameter nbits = 8,
  parameter num_entries = 1
)
(
  input  logic                    clk,
  input  logic                    reset,
  input  logic                    pull_en,
  output logic                    pull_msg_val,
  output logic                    pull_msg_spc,
  output logic [nbits-3:0]        pull_msg_data,
  input  logic                    push_en,
  input  logic                    push_msg_val_wrt,
  input  logic                    push_msg_val_rd,
  input  logic [nbits-3:0]        push_msg_data,
  input  logic [nbits-3:0]        recv_msg,
  output logic                    recv_rdy,
  input  logic                    recv_val,
  output logic [nbits-3:0]        send_msg,
  input  logic                    send_rdy,
  output logic                    send_val,
  output logic                    parity  
);

  logic open_entries;

  logic [nbits-3:0]             cm_q_send_msg;
  logic                         cm_q_send_rdy;
  logic                         cm_q_send_val;

  vc_Queue #(4'b0, nbits-2, num_entries) cm_q
  (
    .clk( clk ),
    .num_free_entries( ),
    .reset( reset ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( cm_q_send_msg ),
    .send_rdy( cm_q_send_rdy ),
    .send_val( cm_q_send_val )
  );

  logic [$clog2(num_entries):0] mc_q_num_free;
  logic                         mc_q_recv_rdy;
  logic                         mc_q_recv_val;

  vc_Queue #(4'b0, nbits-2, num_entries) mc_q
  (
    .clk( clk ),
    .num_free_entries( mc_q_num_free ),
    .reset( reset ),
    .recv_msg( push_msg_data ),
    .recv_rdy( mc_q_recv_rdy ),
    .recv_val( mc_q_recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val )
  );

  assign parity = (^send_msg) & send_val;
  
  always_comb begin : comb_block
    open_entries = mc_q_num_free > 1;
    mc_q_recv_val = push_msg_val_wrt & push_en;
    pull_msg_spc = mc_q_recv_rdy & ( ( ~mc_q_recv_val ) | open_entries );
    cm_q_send_rdy = push_msg_val_rd & pull_en;
    pull_msg_val = cm_q_send_rdy & cm_q_send_val;
    pull_msg_data = cm_q_send_msg & { (nbits-2){pull_msg_val} };
  end

endmodule

`line 6 "SPI_v3/components/SPIMinionAdapterCompositeVRTL.v" 0

module SPI_v3_components_SPIMinionAdapterCompositeVRTL
#(
  parameter nbits = 8,
  parameter num_entries = 1
)
(
  input  logic             clk,
  input  logic             cs,
  output logic             miso,
  input  logic             mosi,
  input  logic             reset,
  input  logic             sclk,
  input  logic [nbits-3:0] recv_msg,
  output logic             recv_rdy,
  input  logic             recv_val,
  output logic [nbits-3:0] send_msg,
  input  logic             send_rdy,
  output logic             send_val,
  output logic             minion_parity,
  output logic             adapter_parity
);

  logic             pull_en;
  logic             pull_msg_val;
  logic             pull_msg_spc;
  logic [nbits-3:0] pull_msg_data;
  logic             push_en;
  logic             push_msg_val_wrt;
  logic             push_msg_val_rd;
  logic [nbits-3:0] push_msg_data;

  logic [nbits-1:0] pull_msg;
  logic [nbits-1:0] push_msg;

  SPI_v3_components_SPIMinionAdapterVRTL #(nbits,num_entries) adapter
  (
    .clk( clk ),
    .reset( reset ),
    .pull_en( pull_en ),
    .pull_msg_val( pull_msg_val ),
    .pull_msg_spc(pull_msg_spc),
    .pull_msg_data(pull_msg_data),
    .push_en( push_en ),
    .push_msg_val_wrt( push_msg_val_wrt ),
    .push_msg_val_rd( push_msg_val_rd ),
    .push_msg_data( push_msg_data ),
    .recv_msg( recv_msg ),
    .recv_rdy( recv_rdy ),
    .recv_val( recv_val ),
    .send_msg( send_msg ),
    .send_rdy( send_rdy ),
    .send_val( send_val ),
    .parity( adapter_parity )
  );

  SPI_v3_components_SPIMinionVRTL #(nbits) minion
  (
    .clk( clk ),
    .cs( cs ),
    .miso( miso ),
    .mosi( mosi ),
    .reset( reset ),
    .sclk( sclk ),
    .pull_en( pull_en ),
    .pull_msg( pull_msg ),
    .push_en( push_en ),
    .push_msg( push_msg ),
    .parity( minion_parity )
  );

  assign pull_msg[nbits-1]   =  pull_msg_val;
  assign pull_msg[nbits-2]   =  pull_msg_spc;
  assign pull_msg[nbits-3:0] =  pull_msg_data;
  assign push_msg_val_wrt = push_msg[nbits-1];
  assign push_msg_val_rd  = push_msg[nbits-2];
  assign push_msg_data    = push_msg[nbits-3:0];

endmodule

`line 10 "SPI_v3/components/SPIstackVRTL.v" 0

module SPI_v3_components_SPIstackVRTL 
#(
    parameter nbits = 34, // the size of the val/rdy msg for the SPI minion
    parameter num_entries = 1
)(
    input  logic clk,
    input  logic reset,

    input  logic loopthrough_sel,
    output logic minion_parity,
    output logic adapter_parity,

    // SPI Minion Ifc
    input  logic sclk,
    input  logic cs,
    input  logic mosi,
    output logic miso,

    // Send/Recv Ifc
    output logic                 send_val,
    output logic [(nbits-2)-1:0] send_msg,
    input  logic                 send_rdy,

    input  logic                 recv_val, 
    input  logic [(nbits-2)-1:0] recv_msg, 
    output logic                 recv_rdy
);

  logic              minion_out_val;
  logic [nbits-3:0]  minion_out_msg;
  logic              minion_out_rdy;

  logic              minion_in_val;
  logic [nbits-3:0]  minion_in_msg;
  logic              minion_in_rdy;


  SPI_v3_components_SPIMinionAdapterCompositeVRTL #(nbits, num_entries) minion
  (
    .clk( clk ),
    .reset( reset ),
    .cs( cs ),
    .miso( miso ),
    .mosi( mosi ),
    .sclk( sclk ),
    .minion_parity( minion_parity ),
    .adapter_parity( adapter_parity ),
    .recv_val( minion_in_val ),
    .recv_msg( minion_in_msg ),
    .recv_rdy( minion_in_rdy ),
    .send_val( minion_out_val ),
    .send_msg( minion_out_msg ),
    .send_rdy( minion_out_rdy )
  );

  SPI_v3_components_LoopThroughVRTL #(nbits-2) loopthrough
  (
    .clk( clk ),
    .reset( reset ),
    .sel( loopthrough_sel ),

    .upstream_req_val( minion_out_val ), 
    .upstream_req_msg( minion_out_msg ), 
    .upstream_req_rdy( minion_out_rdy ), 

    .upstream_resp_val( minion_in_val ),
    .upstream_resp_msg( minion_in_msg ),
    .upstream_resp_rdy( minion_in_rdy ),

    .downstream_req_val( send_val ), 
    .downstream_req_msg( send_msg ), 
    .downstream_req_rdy( send_rdy ), 

    .downstream_resp_val( recv_val ),
    .downstream_resp_msg( recv_msg ),
    .downstream_resp_rdy( recv_rdy )
  );


endmodule
`line 6 "tapeout/SPI_TapeOutBlockVRTL.v" 0
// ADD INCLUDES HERE FOR YOUR MODULE
`line 1 "tapeout/concat_rtl.v" 0

//------> /opt/MentorGraphics/catapult/pkgs/siflibs/ccs_in_wait_v1.v 
//------------------------------------------------------------------------------
// Catapult Synthesis - Sample I/O Port Library
//
// Copyright (c) 2003-2017 Mentor Graphics Corp.
//       All Rights Reserved
//
// This document may be used and distributed without restriction provided that
// this copyright statement is not removed from the file and that any derivative
// work contains this copyright notice.
//
// The design information contained in this file is intended to be an example
// of the functionality which the end user may study in preparation for creating
// their own custom interfaces. This design does not necessarily present a 
// complete implementation of the named protocol or standard.
//
//------------------------------------------------------------------------------


module ccs_in_wait_v1 (idat, rdy, ivld, dat, irdy, vld);

  parameter integer rscid = 1;
  parameter integer width = 8;

  output [width-1:0] idat;
  output             rdy;
  output             ivld;
  input  [width-1:0] dat;
  input              irdy;
  input              vld;

  wire   [width-1:0] idat;
  wire               rdy;
  wire               ivld;

  localparam stallOff = 0; 
  wire                  stall_ctrl;
  assign stall_ctrl = stallOff;

  assign idat = dat;
  assign rdy = irdy && !stall_ctrl;
  assign ivld = vld && !stall_ctrl;

endmodule


//------> /opt/MentorGraphics/catapult/pkgs/siflibs/ccs_out_wait_v1.v 
//------------------------------------------------------------------------------
// Catapult Synthesis - Sample I/O Port Library
//
// Copyright (c) 2003-2017 Mentor Graphics Corp.
//       All Rights Reserved
//
// This document may be used and distributed without restriction provided that
// this copyright statement is not removed from the file and that any derivative
// work contains this copyright notice.
//
// The design information contained in this file is intended to be an example
// of the functionality which the end user may study in preparation for creating
// their own custom interfaces. This design does not necessarily present a 
// complete implementation of the named protocol or standard.
//
//------------------------------------------------------------------------------


module ccs_out_wait_v1 (dat, irdy, vld, idat, rdy, ivld);

  parameter integer rscid = 1;
  parameter integer width = 8;

  output [width-1:0] dat;
  output             irdy;
  output             vld;
  input  [width-1:0] idat;
  input              rdy;
  input              ivld;

  wire   [width-1:0] dat;
  wire               irdy;
  wire               vld;

  localparam stallOff = 0; 
  wire stall_ctrl;
  assign stall_ctrl = stallOff;

  assign dat = idat;
  assign irdy = rdy && !stall_ctrl;
  assign vld = ivld && !stall_ctrl;

endmodule



//------> ./rtl.v 
// ----------------------------------------------------------------------
//  HLS HDL:        Verilog Netlister
//  HLS Version:    2021.1/950854 Production Release
//  HLS Date:       Mon Aug  2 21:36:02 PDT 2021
// 
//  Generated by:   tdt46@en-ec-ecelinux-01.coecis.cornell.edu
//  Generated date: Sat May 21 19:05:18 2022
// ----------------------------------------------------------------------

// 
// ------------------------------------------------------------------
//  Design Unit:    crc32_core_core_fsm
//  FSM Module
// ------------------------------------------------------------------


module crc32_core_core_fsm (
  clk, rst, core_wen, fsm_output, main_C_0_tr0, for_C_0_tr0
);
  input clk;
  input rst;
  input core_wen;
  output [3:0] fsm_output;
  reg [3:0] fsm_output;
  input main_C_0_tr0;
  input for_C_0_tr0;


  // FSM State Type Declaration for crc32_core_core_fsm_1
  parameter
    core_rlp_C_0 = 2'd0,
    main_C_0 = 2'd1,
    for_C_0 = 2'd2,
    main_C_1 = 2'd3;

  reg [1:0] state_var;
  reg [1:0] state_var_NS;


  // Interconnect Declarations for Component Instantiations 
  always @(*)
  begin : crc32_core_core_fsm_1
    case (state_var)
      main_C_0 : begin
        fsm_output = 4'b0010;
        if ( main_C_0_tr0 ) begin
          state_var_NS = main_C_1;
        end
        else begin
          state_var_NS = for_C_0;
        end
      end
      for_C_0 : begin
        fsm_output = 4'b0100;
        if ( for_C_0_tr0 ) begin
          state_var_NS = main_C_1;
        end
        else begin
          state_var_NS = for_C_0;
        end
      end
      main_C_1 : begin
        fsm_output = 4'b1000;
        state_var_NS = main_C_0;
      end
      // core_rlp_C_0
      default : begin
        fsm_output = 4'b0001;
        state_var_NS = main_C_0;
      end
    endcase
  end

  always @(posedge clk) begin
    if ( rst ) begin
      state_var <= core_rlp_C_0;
    end
    else if ( core_wen ) begin
      state_var <= state_var_NS;
    end
  end

endmodule

// ------------------------------------------------------------------
//  Design Unit:    crc32_core_staller
// ------------------------------------------------------------------


module crc32_core_staller (
  core_wen, in_rsci_wen_comp, out_rsci_wen_comp
);
  output core_wen;
  input in_rsci_wen_comp;
  input out_rsci_wen_comp;



  // Interconnect Declarations for Component Instantiations 
  assign core_wen = in_rsci_wen_comp & out_rsci_wen_comp;
endmodule

// ------------------------------------------------------------------
//  Design Unit:    crc32_core_out_rsci_out_wait_ctrl
// ------------------------------------------------------------------


module crc32_core_out_rsci_out_wait_ctrl (
  out_rsci_iswt0, out_rsci_biwt, out_rsci_irdy
);
  input out_rsci_iswt0;
  output out_rsci_biwt;
  input out_rsci_irdy;



  // Interconnect Declarations for Component Instantiations 
  assign out_rsci_biwt = out_rsci_iswt0 & out_rsci_irdy;
endmodule

// ------------------------------------------------------------------
//  Design Unit:    crc32_core_in_rsci_in_wait_ctrl
// ------------------------------------------------------------------


module crc32_core_in_rsci_in_wait_ctrl (
  in_rsci_iswt0, in_rsci_biwt, in_rsci_ivld
);
  input in_rsci_iswt0;
  output in_rsci_biwt;
  input in_rsci_ivld;



  // Interconnect Declarations for Component Instantiations 
  assign in_rsci_biwt = in_rsci_iswt0 & in_rsci_ivld;
endmodule

// ------------------------------------------------------------------
//  Design Unit:    crc32_core_out_rsci
// ------------------------------------------------------------------


module crc32_core_out_rsci (
  out_rsc_dat, out_rsc_vld, out_rsc_rdy, out_rsci_oswt, out_rsci_wen_comp, out_rsci_idat
);
  output [31:0] out_rsc_dat;
  output out_rsc_vld;
  input out_rsc_rdy;
  input out_rsci_oswt;
  output out_rsci_wen_comp;
  input [31:0] out_rsci_idat;


  // Interconnect Declarations
  wire out_rsci_biwt;
  wire out_rsci_irdy;


  // Interconnect Declarations for Component Instantiations 
  ccs_out_wait_v1 #(.rscid(32'sd2),
  .width(32'sd32)) out_rsci (
      .irdy(out_rsci_irdy),
      .ivld(out_rsci_oswt),
      .idat(out_rsci_idat),
      .rdy(out_rsc_rdy),
      .vld(out_rsc_vld),
      .dat(out_rsc_dat)
    );
  crc32_core_out_rsci_out_wait_ctrl crc32_core_out_rsci_out_wait_ctrl_inst (
      .out_rsci_iswt0(out_rsci_oswt),
      .out_rsci_biwt(out_rsci_biwt),
      .out_rsci_irdy(out_rsci_irdy)
    );
  assign out_rsci_wen_comp = (~ out_rsci_oswt) | out_rsci_biwt;
endmodule

// ------------------------------------------------------------------
//  Design Unit:    crc32_core_in_rsci
// ------------------------------------------------------------------


module crc32_core_in_rsci (
  in_rsc_dat, in_rsc_vld, in_rsc_rdy, in_rsci_oswt, in_rsci_wen_comp, in_rsci_idat_mxwt
);
  input [7:0] in_rsc_dat;
  input in_rsc_vld;
  output in_rsc_rdy;
  input in_rsci_oswt;
  output in_rsci_wen_comp;
  output [7:0] in_rsci_idat_mxwt;


  // Interconnect Declarations
  wire in_rsci_biwt;
  wire in_rsci_ivld;
  wire [7:0] in_rsci_idat;


  // Interconnect Declarations for Component Instantiations 
  ccs_in_wait_v1 #(.rscid(32'sd1),
  .width(32'sd8)) in_rsci (
      .rdy(in_rsc_rdy),
      .vld(in_rsc_vld),
      .dat(in_rsc_dat),
      .irdy(in_rsci_oswt),
      .ivld(in_rsci_ivld),
      .idat(in_rsci_idat)
    );
  crc32_core_in_rsci_in_wait_ctrl crc32_core_in_rsci_in_wait_ctrl_inst (
      .in_rsci_iswt0(in_rsci_oswt),
      .in_rsci_biwt(in_rsci_biwt),
      .in_rsci_ivld(in_rsci_ivld)
    );
  assign in_rsci_idat_mxwt = in_rsci_idat;
  assign in_rsci_wen_comp = (~ in_rsci_oswt) | in_rsci_biwt;
endmodule

// ------------------------------------------------------------------
//  Design Unit:    crc32_core
// ------------------------------------------------------------------


module crc32_core (
  clk, rst, in_rsc_dat, in_rsc_vld, in_rsc_rdy, out_rsc_dat, out_rsc_vld, out_rsc_rdy
);
  input clk;
  input rst;
  input [7:0] in_rsc_dat;
  input in_rsc_vld;
  output in_rsc_rdy;
  output [31:0] out_rsc_dat;
  output out_rsc_vld;
  input out_rsc_rdy;


  // Interconnect Declarations
  wire core_wen;
  wire in_rsci_wen_comp;
  wire [7:0] in_rsci_idat_mxwt;
  wire out_rsci_wen_comp;
  reg out_rsci_idat_31;
  reg out_rsci_idat_30;
  reg out_rsci_idat_29;
  reg out_rsci_idat_28;
  reg out_rsci_idat_27;
  reg out_rsci_idat_26;
  reg out_rsci_idat_25;
  reg out_rsci_idat_24;
  reg out_rsci_idat_23;
  reg out_rsci_idat_22;
  reg out_rsci_idat_21;
  reg out_rsci_idat_20;
  reg out_rsci_idat_19;
  reg out_rsci_idat_18;
  reg out_rsci_idat_17;
  reg out_rsci_idat_16;
  reg out_rsci_idat_15;
  reg out_rsci_idat_14;
  reg out_rsci_idat_13;
  reg out_rsci_idat_12;
  reg out_rsci_idat_11;
  reg out_rsci_idat_10;
  reg out_rsci_idat_9;
  reg out_rsci_idat_8;
  reg out_rsci_idat_7;
  reg out_rsci_idat_6;
  reg out_rsci_idat_5;
  reg out_rsci_idat_4;
  reg out_rsci_idat_3;
  reg out_rsci_idat_2;
  reg out_rsci_idat_1;
  reg out_rsci_idat_0;
  wire [3:0] fsm_output;
  wire for_for_8_b_xor_tmp;
  wire for_for_7_b_xor_tmp;
  wire for_for_6_b_xor_tmp;
  wire for_for_5_b_xor_tmp;
  wire for_for_4_b_xor_tmp;
  wire not_tmp_3;
  wire not_tmp_4;
  wire not_tmp_5;
  wire not_tmp_6;
  wire not_tmp_7;
  wire not_tmp_8;
  wire not_tmp_9;
  wire not_tmp_10;
  wire or_tmp_32;
  wire or_tmp_40;
  wire or_tmp_52;
  wire or_tmp_56;
  wire or_tmp_60;
  wire exit_for_sva_mx0;
  reg crc_2_1_sva;
  reg crc_1_1_sva;
  reg crc_0_1_sva;
  wire and_314_cse;
  reg reg_out_rsci_iswt0_cse;
  reg reg_in_rsci_iswt0_cse;
  wire crc_mux_140_cse;
  wire [8:0] z_out;
  wire [9:0] nl_z_out;
  reg [7:0] size_val_sva;
  reg crc_15_1_sva;
  reg crc_16_1_sva;
  reg crc_14_1_sva;
  reg crc_17_1_sva;
  reg crc_13_1_sva;
  reg crc_18_1_sva;
  reg crc_12_1_sva;
  reg crc_19_1_sva;
  reg crc_11_1_sva;
  reg crc_20_1_sva;
  reg crc_10_1_sva;
  reg crc_21_1_sva;
  reg crc_9_1_sva;
  reg crc_22_1_sva;
  reg crc_8_1_sva;
  reg crc_23_1_sva;
  reg crc_7_1_sva;
  reg crc_24_1_sva;
  reg crc_6_1_sva;
  reg crc_25_1_sva;
  reg crc_5_1_sva;
  reg crc_26_1_sva;
  reg crc_4_1_sva;
  reg crc_27_1_sva;
  reg crc_3_1_sva;
  reg crc_28_1_sva;
  reg crc_29_1_sva;
  reg crc_30_1_sva;
  reg crc_31_1_sva;
  reg [7:0] for_i_sva;
  wire crc_5_4_lpi_2_dfm_mx0;
  wire crc_8_2_lpi_2_dfm_mx0;
  wire crc_8_3_lpi_2_dfm_mx0;
  wire crc_8_4_lpi_2_dfm_mx0;
  wire crc_8_5_lpi_2_dfm_mx0;
  wire crc_8_6_lpi_2_dfm_mx0;
  wire crc_9_6_lpi_2_dfm_mx0;
  wire crc_9_7_lpi_2_dfm_mx0;
  wire crc_9_lpi_2_dfm_mx0;
  wire crc_15_3_lpi_2_dfm_mx0;
  wire crc_15_4_lpi_2_dfm_mx0;
  wire crc_15_5_lpi_2_dfm_mx0;
  wire crc_19_2_lpi_2_dfm_mx0;
  wire crc_19_3_lpi_2_dfm_mx0;
  wire crc_19_4_lpi_2_dfm_mx0;
  wire crc_19_5_lpi_2_dfm_mx0;
  wire crc_20_5_lpi_2_dfm_mx0;
  wire crc_20_6_lpi_2_dfm_mx0;
  wire crc_20_7_lpi_2_dfm_mx0;
  wire crc_20_lpi_2_dfm_mx0;
  wire crc_21_lpi_2_dfm_mx0;
  wire crc_23_7_lpi_2_dfm_mx0;
  wire crc_24_7_lpi_2_dfm_mx0;
  wire crc_24_lpi_2_dfm_mx0;
  wire crc_26_7_lpi_2_dfm_mx0;
  wire crc_27_7_lpi_2_dfm_mx0;
  wire crc_27_lpi_2_dfm_mx0;
  wire crc_29_7_lpi_2_dfm_mx0;
  wire crc_30_7_lpi_2_dfm_mx0;
  wire crc_30_lpi_2_dfm_mx0;
  wire for_for_b_2_sva_1;
  wire crc_15_2_lpi_2_dfm_mx0;
  wire crc_21_7_lpi_2_dfm_mx0;
  wire crc_23_6_lpi_2_dfm_mx0;
  wire crc_26_6_lpi_2_dfm_mx0;
  wire crc_29_6_lpi_2_dfm_mx0;
  wire for_for_b_1_sva_1;
  wire crc_21_6_lpi_2_dfm_mx0;
  wire crc_23_5_lpi_2_dfm_mx0;
  wire crc_24_6_lpi_2_dfm_mx0;
  wire crc_26_5_lpi_2_dfm_mx0;
  wire crc_27_6_lpi_2_dfm_mx0;
  wire crc_29_5_lpi_2_dfm_mx0;
  wire crc_30_6_lpi_2_dfm_mx0;
  wire crc_9_5_lpi_2_dfm_mx0;
  wire crc_21_5_lpi_2_dfm_mx0;
  wire crc_23_4_lpi_2_dfm_mx0;
  wire crc_24_5_lpi_2_dfm_mx0;
  wire crc_26_4_lpi_2_dfm_mx0;
  wire crc_27_5_lpi_2_dfm_mx0;
  wire crc_29_4_lpi_2_dfm_mx0;
  wire crc_30_5_lpi_2_dfm_mx0;
  wire crc_9_4_lpi_2_dfm_mx0;
  wire crc_20_4_lpi_2_dfm_mx0;
  wire crc_21_4_lpi_2_dfm_mx0;
  wire crc_23_3_lpi_2_dfm_mx0;
  wire crc_24_4_lpi_2_dfm_mx0;
  wire crc_26_3_lpi_2_dfm_mx0;
  wire crc_27_4_lpi_2_dfm_mx0;
  wire crc_29_3_lpi_2_dfm_mx0;
  wire crc_30_4_lpi_2_dfm_mx0;
  wire for_for_b_3_sva_1;
  wire crc_9_3_lpi_2_dfm_mx0;
  wire crc_20_3_lpi_2_dfm_mx0;
  wire crc_21_3_lpi_2_dfm_mx0;
  wire crc_23_2_lpi_2_dfm_mx0;
  wire crc_24_3_lpi_2_dfm_mx0;
  wire crc_26_2_lpi_2_dfm_mx0;
  wire crc_27_3_lpi_2_dfm_mx0;
  wire crc_29_2_lpi_2_dfm_mx0;
  wire crc_30_3_lpi_2_dfm_mx0;
  wire crc_9_2_lpi_2_dfm_mx0;
  wire crc_20_2_lpi_2_dfm_mx0;
  wire crc_21_2_lpi_2_dfm_mx0;
  wire crc_24_2_lpi_2_dfm_mx0;
  wire crc_27_2_lpi_2_dfm_mx0;
  wire crc_30_2_lpi_2_dfm_mx0;
  wire xor_cse_1;
  wire xor_cse_5;

  wire crc_mux_142_nl;
  wire crc_mux_144_nl;
  wire crc_mux_146_nl;
  wire crc_mux_148_nl;
  wire crc_mux_150_nl;
  wire crc_mux_152_nl;
  wire crc_mux_154_nl;
  wire crc_mux_156_nl;
  wire crc_mux_160_nl;
  wire crc_mux_162_nl;
  wire crc_mux_164_nl;
  wire crc_mux_166_nl;
  wire crc_mux_165_nl;
  wire crc_mux_163_nl;
  wire crc_mux_161_nl;
  wire crc_mux_159_nl;
  wire crc_mux_158_nl;
  wire crc_mux_157_nl;
  wire crc_mux_155_nl;
  wire crc_mux_153_nl;
  wire crc_mux_151_nl;
  wire crc_mux_149_nl;
  wire crc_mux_147_nl;
  wire crc_mux_145_nl;
  wire crc_mux_143_nl;
  wire crc_mux_141_nl;
  wire crc_mux_nl;
  wire crc_mux_167_nl;
  wire crc_mux_168_nl;
  wire crc_mux_169_nl;
  wire crc_mux_170_nl;
  wire crc_mux_171_nl;
  wire crc_mux_172_nl;
  wire crc_mux_173_nl;
  wire crc_mux_174_nl;
  wire crc_mux_175_nl;
  wire crc_mux_176_nl;
  wire crc_mux_177_nl;
  wire crc_mux_178_nl;
  wire crc_mux_179_nl;
  wire crc_mux_180_nl;
  wire crc_mux_181_nl;
  wire crc_mux_182_nl;
  wire crc_mux_183_nl;
  wire crc_mux_184_nl;
  wire crc_mux_185_nl;
  wire crc_mux_186_nl;
  wire crc_mux_187_nl;
  wire crc_mux_188_nl;
  wire crc_mux_189_nl;
  wire crc_mux_190_nl;
  wire crc_mux_191_nl;
  wire crc_mux_192_nl;
  wire crc_mux_193_nl;
  wire[8:0] for_acc_nl;
  wire[7:0] for_mux_2_nl;

  // Interconnect Declarations for Component Instantiations 
  wire [31:0] nl_crc32_core_out_rsci_inst_out_rsci_idat;
  assign nl_crc32_core_out_rsci_inst_out_rsci_idat = {out_rsci_idat_31 , out_rsci_idat_30
      , out_rsci_idat_29 , out_rsci_idat_28 , out_rsci_idat_27 , out_rsci_idat_26
      , out_rsci_idat_25 , out_rsci_idat_24 , out_rsci_idat_23 , out_rsci_idat_22
      , out_rsci_idat_21 , out_rsci_idat_20 , out_rsci_idat_19 , out_rsci_idat_18
      , out_rsci_idat_17 , out_rsci_idat_16 , out_rsci_idat_15 , out_rsci_idat_14
      , out_rsci_idat_13 , out_rsci_idat_12 , out_rsci_idat_11 , out_rsci_idat_10
      , out_rsci_idat_9 , out_rsci_idat_8 , out_rsci_idat_7 , out_rsci_idat_6 , out_rsci_idat_5
      , out_rsci_idat_4 , out_rsci_idat_3 , out_rsci_idat_2 , out_rsci_idat_1 , out_rsci_idat_0};
  crc32_core_in_rsci crc32_core_in_rsci_inst (
      .in_rsc_dat(in_rsc_dat),
      .in_rsc_vld(in_rsc_vld),
      .in_rsc_rdy(in_rsc_rdy),
      .in_rsci_oswt(reg_in_rsci_iswt0_cse),
      .in_rsci_wen_comp(in_rsci_wen_comp),
      .in_rsci_idat_mxwt(in_rsci_idat_mxwt)
    );
  crc32_core_out_rsci crc32_core_out_rsci_inst (
      .out_rsc_dat(out_rsc_dat),
      .out_rsc_vld(out_rsc_vld),
      .out_rsc_rdy(out_rsc_rdy),
      .out_rsci_oswt(reg_out_rsci_iswt0_cse),
      .out_rsci_wen_comp(out_rsci_wen_comp),
      .out_rsci_idat(nl_crc32_core_out_rsci_inst_out_rsci_idat[31:0])
    );
  crc32_core_staller crc32_core_staller_inst (
      .core_wen(core_wen),
      .in_rsci_wen_comp(in_rsci_wen_comp),
      .out_rsci_wen_comp(out_rsci_wen_comp)
    );
  crc32_core_core_fsm crc32_core_core_fsm_inst (
      .clk(clk),
      .rst(rst),
      .core_wen(core_wen),
      .fsm_output(fsm_output),
      .main_C_0_tr0(exit_for_sva_mx0),
      .for_C_0_tr0(exit_for_sva_mx0)
    );
  assign and_314_cse = core_wen & (~((fsm_output[0]) | (fsm_output[3]) | (~ exit_for_sva_mx0)));
  assign crc_mux_140_cse = MUX_s_1_2_2((~ crc_8_2_lpi_2_dfm_mx0), crc_8_2_lpi_2_dfm_mx0,
      not_tmp_4);
  assign for_acc_nl = $signed((z_out[7:0])) - $signed(size_val_sva);
  assign exit_for_sva_mx0 = MUX_s_1_2_2((~ (z_out[8])), (~ (readslicef_9_1_8(for_acc_nl))),
      fsm_output[2]);
  assign crc_5_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_8_1_sva), crc_8_1_sva, not_tmp_8);
  assign crc_8_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_9_1_sva), crc_9_1_sva, not_tmp_9);
  assign for_for_4_b_xor_tmp = (in_rsci_idat_mxwt[3]) ^ crc_3_1_sva;
  assign crc_8_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_9_2_lpi_2_dfm_mx0), crc_9_2_lpi_2_dfm_mx0,
      not_tmp_10);
  assign for_for_5_b_xor_tmp = (in_rsci_idat_mxwt[4]) ^ crc_4_1_sva;
  assign crc_8_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_9_3_lpi_2_dfm_mx0), crc_9_3_lpi_2_dfm_mx0,
      not_tmp_8);
  assign for_for_6_b_xor_tmp = (in_rsci_idat_mxwt[5]) ^ crc_5_1_sva;
  assign crc_8_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_9_4_lpi_2_dfm_mx0), crc_9_4_lpi_2_dfm_mx0,
      not_tmp_4);
  assign for_for_7_b_xor_tmp = (in_rsci_idat_mxwt[6]) ^ xor_cse_5;
  assign crc_8_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_9_5_lpi_2_dfm_mx0), crc_9_5_lpi_2_dfm_mx0,
      not_tmp_5);
  assign for_for_8_b_xor_tmp = (in_rsci_idat_mxwt[7]) ^ xor_cse_1;
  assign crc_9_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_14_1_sva), crc_14_1_sva, not_tmp_5);
  assign crc_9_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_15_1_sva), crc_15_1_sva, not_tmp_7);
  assign crc_9_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_15_2_lpi_2_dfm_mx0), crc_15_2_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_15_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_17_1_sva), crc_17_1_sva, not_tmp_10);
  assign crc_15_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_18_1_sva), crc_18_1_sva, not_tmp_8);
  assign crc_15_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_19_1_sva), crc_19_1_sva, not_tmp_4);
  assign crc_19_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_20_1_sva), crc_20_1_sva, not_tmp_9);
  assign crc_19_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_20_2_lpi_2_dfm_mx0), crc_20_2_lpi_2_dfm_mx0,
      not_tmp_10);
  assign crc_19_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_20_3_lpi_2_dfm_mx0), crc_20_3_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_19_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_20_4_lpi_2_dfm_mx0), crc_20_4_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_20_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_21_4_lpi_2_dfm_mx0), crc_21_4_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_20_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_21_5_lpi_2_dfm_mx0), crc_21_5_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_20_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_21_6_lpi_2_dfm_mx0), crc_21_6_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_20_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_21_7_lpi_2_dfm_mx0), crc_21_7_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_21_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_23_6_lpi_2_dfm_mx0), crc_23_6_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_23_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_24_6_lpi_2_dfm_mx0), crc_24_6_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_24_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_26_5_lpi_2_dfm_mx0), crc_26_5_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_24_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_26_6_lpi_2_dfm_mx0), crc_26_6_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_26_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_27_6_lpi_2_dfm_mx0), crc_27_6_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_27_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_29_5_lpi_2_dfm_mx0), crc_29_5_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_27_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_29_6_lpi_2_dfm_mx0), crc_29_6_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_29_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_30_6_lpi_2_dfm_mx0), crc_30_6_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_30_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ for_for_5_b_xor_tmp), for_for_5_b_xor_tmp,
      not_tmp_7);
  assign crc_30_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ for_for_6_b_xor_tmp), for_for_6_b_xor_tmp,
      not_tmp_6);
  assign for_for_b_2_sva_1 = (in_rsci_idat_mxwt[1]) ^ crc_1_1_sva;
  assign crc_15_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_16_1_sva), crc_16_1_sva, not_tmp_9);
  assign crc_21_7_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_23_5_lpi_2_dfm_mx0), crc_23_5_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_23_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_24_5_lpi_2_dfm_mx0), crc_24_5_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_26_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_27_5_lpi_2_dfm_mx0), crc_27_5_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_29_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_30_5_lpi_2_dfm_mx0), crc_30_5_lpi_2_dfm_mx0,
      not_tmp_5);
  assign for_for_b_1_sva_1 = (in_rsci_idat_mxwt[0]) ^ crc_0_1_sva;
  assign crc_21_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_23_4_lpi_2_dfm_mx0), crc_23_4_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_23_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_24_4_lpi_2_dfm_mx0), crc_24_4_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_24_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_26_4_lpi_2_dfm_mx0), crc_26_4_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_26_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_27_4_lpi_2_dfm_mx0), crc_27_4_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_27_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_29_4_lpi_2_dfm_mx0), crc_29_4_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_29_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_30_4_lpi_2_dfm_mx0), crc_30_4_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_30_6_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ for_for_4_b_xor_tmp), for_for_4_b_xor_tmp,
      not_tmp_5);
  assign crc_9_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_13_1_sva), crc_13_1_sva, not_tmp_4);
  assign crc_21_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_23_3_lpi_2_dfm_mx0), crc_23_3_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_23_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_24_3_lpi_2_dfm_mx0), crc_24_3_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_24_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_26_3_lpi_2_dfm_mx0), crc_26_3_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_26_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_27_3_lpi_2_dfm_mx0), crc_27_3_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_27_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_29_3_lpi_2_dfm_mx0), crc_29_3_lpi_2_dfm_mx0,
      not_tmp_4);
  assign crc_29_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_30_3_lpi_2_dfm_mx0), crc_30_3_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_30_5_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ for_for_b_3_sva_1), for_for_b_3_sva_1,
      not_tmp_4);
  assign crc_9_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_12_1_sva), crc_12_1_sva, not_tmp_8);
  assign crc_20_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_21_3_lpi_2_dfm_mx0), crc_21_3_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_21_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_23_2_lpi_2_dfm_mx0), crc_23_2_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_23_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_24_2_lpi_2_dfm_mx0), crc_24_2_lpi_2_dfm_mx0,
      not_tmp_10);
  assign crc_24_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_26_2_lpi_2_dfm_mx0), crc_26_2_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_26_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_27_2_lpi_2_dfm_mx0), crc_27_2_lpi_2_dfm_mx0,
      not_tmp_10);
  assign crc_27_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_29_2_lpi_2_dfm_mx0), crc_29_2_lpi_2_dfm_mx0,
      not_tmp_8);
  assign crc_29_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_30_2_lpi_2_dfm_mx0), crc_30_2_lpi_2_dfm_mx0,
      not_tmp_10);
  assign crc_30_4_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ for_for_b_2_sva_1), for_for_b_2_sva_1,
      not_tmp_8);
  assign for_for_b_3_sva_1 = (in_rsci_idat_mxwt[2]) ^ crc_2_1_sva;
  assign crc_9_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_11_1_sva), crc_11_1_sva, not_tmp_10);
  assign crc_20_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_21_2_lpi_2_dfm_mx0), crc_21_2_lpi_2_dfm_mx0,
      not_tmp_10);
  assign crc_21_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_23_1_sva), crc_23_1_sva, not_tmp_10);
  assign crc_23_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_24_1_sva), crc_24_1_sva, not_tmp_9);
  assign crc_24_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_26_1_sva), crc_26_1_sva, not_tmp_10);
  assign crc_26_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_27_1_sva), crc_27_1_sva, not_tmp_9);
  assign crc_27_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_29_1_sva), crc_29_1_sva, not_tmp_10);
  assign crc_29_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_30_1_sva), crc_30_1_sva, not_tmp_9);
  assign crc_30_3_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ for_for_b_1_sva_1), for_for_b_1_sva_1,
      not_tmp_10);
  assign crc_9_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_10_1_sva), crc_10_1_sva, not_tmp_9);
  assign crc_20_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_21_1_sva), crc_21_1_sva, not_tmp_9);
  assign crc_21_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_22_1_sva), crc_22_1_sva, not_tmp_9);
  assign crc_24_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_25_1_sva), crc_25_1_sva, not_tmp_9);
  assign crc_27_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_28_1_sva), crc_28_1_sva, not_tmp_9);
  assign crc_30_2_lpi_2_dfm_mx0 = MUX_s_1_2_2((~ crc_31_1_sva), crc_31_1_sva, not_tmp_9);
  assign or_tmp_32 = exit_for_sva_mx0 & ((fsm_output[2:1]!=2'b00));
  assign or_tmp_40 = not_tmp_3 & (fsm_output[2]);
  assign or_tmp_52 = not_tmp_5 & (fsm_output[2]);
  assign or_tmp_56 = not_tmp_6 & (fsm_output[2]);
  assign or_tmp_60 = not_tmp_7 & (fsm_output[2]);
  assign xor_cse_1 = MUX_s_1_2_2(crc_7_1_sva, (~ crc_7_1_sva), for_for_b_2_sva_1);
  assign not_tmp_3 = ~((in_rsci_idat_mxwt[7]) ^ xor_cse_1);
  assign not_tmp_4 = ~((in_rsci_idat_mxwt[3]) ^ crc_3_1_sva);
  assign not_tmp_5 = ~((in_rsci_idat_mxwt[4]) ^ crc_4_1_sva);
  assign xor_cse_5 = MUX_s_1_2_2(crc_6_1_sva, (~ crc_6_1_sva), for_for_b_1_sva_1);
  assign not_tmp_6 = ~((in_rsci_idat_mxwt[6]) ^ xor_cse_5);
  assign not_tmp_7 = ~((in_rsci_idat_mxwt[5]) ^ crc_5_1_sva);
  assign not_tmp_8 = ~((in_rsci_idat_mxwt[2]) ^ crc_2_1_sva);
  assign not_tmp_9 = ~((in_rsci_idat_mxwt[0]) ^ crc_0_1_sva);
  assign not_tmp_10 = ~((in_rsci_idat_mxwt[1]) ^ crc_1_1_sva);
  always @(posedge clk) begin
    if ( rst ) begin
      out_rsci_idat_0 <= 1'b0;
      out_rsci_idat_1 <= 1'b0;
      out_rsci_idat_2 <= 1'b0;
      out_rsci_idat_3 <= 1'b0;
      out_rsci_idat_4 <= 1'b0;
      out_rsci_idat_5 <= 1'b0;
      out_rsci_idat_6 <= 1'b0;
      out_rsci_idat_7 <= 1'b0;
      out_rsci_idat_8 <= 1'b0;
      out_rsci_idat_9 <= 1'b0;
      out_rsci_idat_10 <= 1'b0;
      out_rsci_idat_11 <= 1'b0;
      out_rsci_idat_12 <= 1'b0;
      out_rsci_idat_13 <= 1'b0;
      out_rsci_idat_14 <= 1'b0;
      out_rsci_idat_15 <= 1'b0;
      out_rsci_idat_16 <= 1'b0;
      out_rsci_idat_17 <= 1'b0;
      out_rsci_idat_18 <= 1'b0;
      out_rsci_idat_19 <= 1'b0;
      out_rsci_idat_20 <= 1'b0;
      out_rsci_idat_21 <= 1'b0;
      out_rsci_idat_22 <= 1'b0;
      out_rsci_idat_23 <= 1'b0;
      out_rsci_idat_24 <= 1'b0;
      out_rsci_idat_25 <= 1'b0;
      out_rsci_idat_26 <= 1'b0;
      out_rsci_idat_27 <= 1'b0;
      out_rsci_idat_28 <= 1'b0;
      out_rsci_idat_29 <= 1'b0;
      out_rsci_idat_30 <= 1'b0;
      out_rsci_idat_31 <= 1'b0;
    end
    else if ( and_314_cse ) begin
      out_rsci_idat_0 <= ~(crc_5_4_lpi_2_dfm_mx0 | (~ (fsm_output[2])));
      out_rsci_idat_1 <= ~(crc_mux_140_cse | (~ (fsm_output[2])));
      out_rsci_idat_2 <= ~(crc_mux_142_nl | (~ (fsm_output[2])));
      out_rsci_idat_3 <= ~(crc_mux_144_nl | (~ (fsm_output[2])));
      out_rsci_idat_4 <= ~(crc_mux_146_nl | (~ (fsm_output[2])));
      out_rsci_idat_5 <= ~(crc_mux_148_nl | (~ (fsm_output[2])));
      out_rsci_idat_6 <= ~(crc_mux_150_nl | (~ (fsm_output[2])));
      out_rsci_idat_7 <= ~(crc_mux_152_nl | (~ (fsm_output[2])));
      out_rsci_idat_8 <= ~(crc_mux_154_nl | (~ (fsm_output[2])));
      out_rsci_idat_9 <= ~(crc_mux_156_nl | (~ (fsm_output[2])));
      out_rsci_idat_10 <= ~(crc_15_4_lpi_2_dfm_mx0 | (~ (fsm_output[2])));
      out_rsci_idat_11 <= ~(crc_15_5_lpi_2_dfm_mx0 | (~ (fsm_output[2])));
      out_rsci_idat_12 <= ~(crc_mux_160_nl | (~ (fsm_output[2])));
      out_rsci_idat_13 <= ~(crc_mux_162_nl | (~ (fsm_output[2])));
      out_rsci_idat_14 <= ~(crc_mux_164_nl | (~ (fsm_output[2])));
      out_rsci_idat_15 <= ~(crc_mux_166_nl | (~ (fsm_output[2])));
      out_rsci_idat_16 <= ~(crc_mux_165_nl | (~ (fsm_output[2])));
      out_rsci_idat_17 <= ~(crc_mux_163_nl | (~ (fsm_output[2])));
      out_rsci_idat_18 <= ~(crc_mux_161_nl | (~ (fsm_output[2])));
      out_rsci_idat_19 <= ~(crc_mux_159_nl | (~ (fsm_output[2])));
      out_rsci_idat_20 <= ~(crc_mux_158_nl | (~ (fsm_output[2])));
      out_rsci_idat_21 <= ~(crc_mux_157_nl | (~ (fsm_output[2])));
      out_rsci_idat_22 <= ~(crc_mux_155_nl | (~ (fsm_output[2])));
      out_rsci_idat_23 <= ~(crc_mux_153_nl | (~ (fsm_output[2])));
      out_rsci_idat_24 <= ~(crc_mux_151_nl | (~ (fsm_output[2])));
      out_rsci_idat_25 <= ~(crc_mux_149_nl | (~ (fsm_output[2])));
      out_rsci_idat_26 <= ~(crc_mux_147_nl | (~ (fsm_output[2])));
      out_rsci_idat_27 <= ~(crc_mux_145_nl | (~ (fsm_output[2])));
      out_rsci_idat_28 <= ~(crc_mux_143_nl | (~ (fsm_output[2])));
      out_rsci_idat_29 <= ~(crc_mux_141_nl | (~ (fsm_output[2])));
      out_rsci_idat_30 <= ~(crc_mux_nl | (~ (fsm_output[2])));
      out_rsci_idat_31 <= ~(for_for_8_b_xor_tmp | (~ (fsm_output[2])));
    end
  end
  always @(posedge clk) begin
    if ( rst ) begin
      reg_out_rsci_iswt0_cse <= 1'b0;
      reg_in_rsci_iswt0_cse <= 1'b0;
      crc_31_1_sva <= 1'b0;
      crc_0_1_sva <= 1'b0;
      crc_30_1_sva <= 1'b0;
      crc_1_1_sva <= 1'b0;
      crc_29_1_sva <= 1'b0;
      crc_2_1_sva <= 1'b0;
      crc_28_1_sva <= 1'b0;
      crc_3_1_sva <= 1'b0;
      crc_27_1_sva <= 1'b0;
      crc_4_1_sva <= 1'b0;
      crc_26_1_sva <= 1'b0;
      crc_5_1_sva <= 1'b0;
      crc_25_1_sva <= 1'b0;
      crc_6_1_sva <= 1'b0;
      crc_24_1_sva <= 1'b0;
      crc_7_1_sva <= 1'b0;
      crc_23_1_sva <= 1'b0;
      crc_8_1_sva <= 1'b0;
      crc_22_1_sva <= 1'b0;
      crc_9_1_sva <= 1'b0;
      crc_21_1_sva <= 1'b0;
      crc_10_1_sva <= 1'b0;
      crc_20_1_sva <= 1'b0;
      crc_11_1_sva <= 1'b0;
      crc_19_1_sva <= 1'b0;
      crc_12_1_sva <= 1'b0;
      crc_18_1_sva <= 1'b0;
      crc_13_1_sva <= 1'b0;
      crc_17_1_sva <= 1'b0;
      crc_14_1_sva <= 1'b0;
      crc_16_1_sva <= 1'b0;
      crc_15_1_sva <= 1'b0;
      for_i_sva <= 8'b00000000;
    end
    else if ( core_wen ) begin
      reg_out_rsci_iswt0_cse <= or_tmp_32;
      reg_in_rsci_iswt0_cse <= ~ or_tmp_32;
      crc_31_1_sva <= for_for_8_b_xor_tmp | (~ (fsm_output[2]));
      crc_0_1_sva <= crc_5_4_lpi_2_dfm_mx0 | (~ (fsm_output[2]));
      crc_30_1_sva <= crc_mux_167_nl | (~ (fsm_output[2]));
      crc_1_1_sva <= crc_mux_140_cse | (~ (fsm_output[2]));
      crc_29_1_sva <= crc_mux_168_nl | (~ (fsm_output[2]));
      crc_2_1_sva <= crc_mux_169_nl | (~ (fsm_output[2]));
      crc_28_1_sva <= crc_mux_170_nl | (~ (fsm_output[2]));
      crc_3_1_sva <= crc_mux_171_nl | (~ (fsm_output[2]));
      crc_27_1_sva <= crc_mux_172_nl | (~ (fsm_output[2]));
      crc_4_1_sva <= crc_mux_173_nl | (~ (fsm_output[2]));
      crc_26_1_sva <= crc_mux_174_nl | (~ (fsm_output[2]));
      crc_5_1_sva <= crc_mux_175_nl | (~ (fsm_output[2]));
      crc_25_1_sva <= crc_mux_176_nl | (~ (fsm_output[2]));
      crc_6_1_sva <= crc_mux_177_nl | (~ (fsm_output[2]));
      crc_24_1_sva <= crc_mux_178_nl | (~ (fsm_output[2]));
      crc_7_1_sva <= crc_mux_179_nl | (~ (fsm_output[2]));
      crc_23_1_sva <= crc_mux_180_nl | (~ (fsm_output[2]));
      crc_8_1_sva <= crc_mux_181_nl | (~ (fsm_output[2]));
      crc_22_1_sva <= crc_mux_182_nl | (~ (fsm_output[2]));
      crc_9_1_sva <= crc_mux_183_nl | (~ (fsm_output[2]));
      crc_21_1_sva <= crc_mux_184_nl | (~ (fsm_output[2]));
      crc_10_1_sva <= crc_15_4_lpi_2_dfm_mx0 | (~ (fsm_output[2]));
      crc_20_1_sva <= crc_mux_185_nl | (~ (fsm_output[2]));
      crc_11_1_sva <= crc_15_5_lpi_2_dfm_mx0 | (~ (fsm_output[2]));
      crc_19_1_sva <= crc_mux_186_nl | (~ (fsm_output[2]));
      crc_12_1_sva <= crc_mux_187_nl | (~ (fsm_output[2]));
      crc_18_1_sva <= crc_mux_188_nl | (~ (fsm_output[2]));
      crc_13_1_sva <= crc_mux_189_nl | (~ (fsm_output[2]));
      crc_17_1_sva <= crc_mux_190_nl | (~ (fsm_output[2]));
      crc_14_1_sva <= crc_mux_191_nl | (~ (fsm_output[2]));
      crc_16_1_sva <= crc_mux_192_nl | (~ (fsm_output[2]));
      crc_15_1_sva <= crc_mux_193_nl | (~ (fsm_output[2]));
      for_i_sva <= MUX_v_8_2_2(8'b00000000, (z_out[7:0]), (fsm_output[2]));
    end
  end
  always @(posedge clk) begin
    if ( rst ) begin
      size_val_sva <= 8'b00000000;
    end
    else if ( core_wen & (~ (fsm_output[2])) ) begin
      size_val_sva <= in_rsci_idat_mxwt;
    end
  end
  assign crc_mux_142_nl = MUX_s_1_2_2((~ crc_8_3_lpi_2_dfm_mx0), crc_8_3_lpi_2_dfm_mx0,
      or_tmp_52);
  assign crc_mux_144_nl = MUX_s_1_2_2((~ crc_8_4_lpi_2_dfm_mx0), crc_8_4_lpi_2_dfm_mx0,
      or_tmp_60);
  assign crc_mux_146_nl = MUX_s_1_2_2((~ crc_8_5_lpi_2_dfm_mx0), crc_8_5_lpi_2_dfm_mx0,
      or_tmp_56);
  assign crc_mux_148_nl = MUX_s_1_2_2((~ crc_8_6_lpi_2_dfm_mx0), crc_8_6_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_150_nl = MUX_s_1_2_2((~ crc_9_6_lpi_2_dfm_mx0), crc_9_6_lpi_2_dfm_mx0,
      or_tmp_60);
  assign crc_mux_152_nl = MUX_s_1_2_2((~ crc_9_7_lpi_2_dfm_mx0), crc_9_7_lpi_2_dfm_mx0,
      or_tmp_56);
  assign crc_mux_154_nl = MUX_s_1_2_2((~ crc_9_lpi_2_dfm_mx0), crc_9_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_156_nl = MUX_s_1_2_2((~ crc_15_3_lpi_2_dfm_mx0), crc_15_3_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_160_nl = MUX_s_1_2_2((~ crc_19_2_lpi_2_dfm_mx0), crc_19_2_lpi_2_dfm_mx0,
      or_tmp_52);
  assign crc_mux_162_nl = MUX_s_1_2_2((~ crc_19_3_lpi_2_dfm_mx0), crc_19_3_lpi_2_dfm_mx0,
      or_tmp_60);
  assign crc_mux_164_nl = MUX_s_1_2_2((~ crc_19_4_lpi_2_dfm_mx0), crc_19_4_lpi_2_dfm_mx0,
      or_tmp_56);
  assign crc_mux_166_nl = MUX_s_1_2_2((~ crc_19_5_lpi_2_dfm_mx0), crc_19_5_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_165_nl = MUX_s_1_2_2((~ crc_20_5_lpi_2_dfm_mx0), crc_20_5_lpi_2_dfm_mx0,
      or_tmp_52);
  assign crc_mux_163_nl = MUX_s_1_2_2((~ crc_20_6_lpi_2_dfm_mx0), crc_20_6_lpi_2_dfm_mx0,
      or_tmp_60);
  assign crc_mux_161_nl = MUX_s_1_2_2((~ crc_20_7_lpi_2_dfm_mx0), crc_20_7_lpi_2_dfm_mx0,
      or_tmp_56);
  assign crc_mux_159_nl = MUX_s_1_2_2((~ crc_20_lpi_2_dfm_mx0), crc_20_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_158_nl = MUX_s_1_2_2((~ crc_21_lpi_2_dfm_mx0), crc_21_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_157_nl = MUX_s_1_2_2((~ crc_23_7_lpi_2_dfm_mx0), crc_23_7_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_155_nl = MUX_s_1_2_2((~ crc_24_7_lpi_2_dfm_mx0), crc_24_7_lpi_2_dfm_mx0,
      or_tmp_56);
  assign crc_mux_153_nl = MUX_s_1_2_2((~ crc_24_lpi_2_dfm_mx0), crc_24_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_151_nl = MUX_s_1_2_2((~ crc_26_7_lpi_2_dfm_mx0), crc_26_7_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_149_nl = MUX_s_1_2_2((~ crc_27_7_lpi_2_dfm_mx0), crc_27_7_lpi_2_dfm_mx0,
      or_tmp_56);
  assign crc_mux_147_nl = MUX_s_1_2_2((~ crc_27_lpi_2_dfm_mx0), crc_27_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_145_nl = MUX_s_1_2_2((~ crc_29_7_lpi_2_dfm_mx0), crc_29_7_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_143_nl = MUX_s_1_2_2((~ crc_30_7_lpi_2_dfm_mx0), crc_30_7_lpi_2_dfm_mx0,
      or_tmp_56);
  assign crc_mux_141_nl = MUX_s_1_2_2((~ crc_30_lpi_2_dfm_mx0), crc_30_lpi_2_dfm_mx0,
      or_tmp_40);
  assign crc_mux_nl = MUX_s_1_2_2((~ for_for_7_b_xor_tmp), for_for_7_b_xor_tmp, or_tmp_40);
  assign crc_mux_167_nl = MUX_s_1_2_2((~ for_for_7_b_xor_tmp), for_for_7_b_xor_tmp,
      not_tmp_3);
  assign crc_mux_168_nl = MUX_s_1_2_2((~ crc_30_lpi_2_dfm_mx0), crc_30_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_169_nl = MUX_s_1_2_2((~ crc_8_3_lpi_2_dfm_mx0), crc_8_3_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_mux_170_nl = MUX_s_1_2_2((~ crc_30_7_lpi_2_dfm_mx0), crc_30_7_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_mux_171_nl = MUX_s_1_2_2((~ crc_8_4_lpi_2_dfm_mx0), crc_8_4_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_mux_172_nl = MUX_s_1_2_2((~ crc_29_7_lpi_2_dfm_mx0), crc_29_7_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_173_nl = MUX_s_1_2_2((~ crc_8_5_lpi_2_dfm_mx0), crc_8_5_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_mux_174_nl = MUX_s_1_2_2((~ crc_27_lpi_2_dfm_mx0), crc_27_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_175_nl = MUX_s_1_2_2((~ crc_8_6_lpi_2_dfm_mx0), crc_8_6_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_176_nl = MUX_s_1_2_2((~ crc_27_7_lpi_2_dfm_mx0), crc_27_7_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_mux_177_nl = MUX_s_1_2_2((~ crc_9_6_lpi_2_dfm_mx0), crc_9_6_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_mux_178_nl = MUX_s_1_2_2((~ crc_26_7_lpi_2_dfm_mx0), crc_26_7_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_179_nl = MUX_s_1_2_2((~ crc_9_7_lpi_2_dfm_mx0), crc_9_7_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_mux_180_nl = MUX_s_1_2_2((~ crc_24_lpi_2_dfm_mx0), crc_24_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_181_nl = MUX_s_1_2_2((~ crc_9_lpi_2_dfm_mx0), crc_9_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_182_nl = MUX_s_1_2_2((~ crc_24_7_lpi_2_dfm_mx0), crc_24_7_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_mux_183_nl = MUX_s_1_2_2((~ crc_15_3_lpi_2_dfm_mx0), crc_15_3_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_184_nl = MUX_s_1_2_2((~ crc_23_7_lpi_2_dfm_mx0), crc_23_7_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_185_nl = MUX_s_1_2_2((~ crc_21_lpi_2_dfm_mx0), crc_21_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_186_nl = MUX_s_1_2_2((~ crc_20_lpi_2_dfm_mx0), crc_20_lpi_2_dfm_mx0,
      not_tmp_3);
  assign crc_mux_187_nl = MUX_s_1_2_2((~ crc_19_2_lpi_2_dfm_mx0), crc_19_2_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_mux_188_nl = MUX_s_1_2_2((~ crc_20_7_lpi_2_dfm_mx0), crc_20_7_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_mux_189_nl = MUX_s_1_2_2((~ crc_19_3_lpi_2_dfm_mx0), crc_19_3_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_mux_190_nl = MUX_s_1_2_2((~ crc_20_6_lpi_2_dfm_mx0), crc_20_6_lpi_2_dfm_mx0,
      not_tmp_7);
  assign crc_mux_191_nl = MUX_s_1_2_2((~ crc_19_4_lpi_2_dfm_mx0), crc_19_4_lpi_2_dfm_mx0,
      not_tmp_6);
  assign crc_mux_192_nl = MUX_s_1_2_2((~ crc_20_5_lpi_2_dfm_mx0), crc_20_5_lpi_2_dfm_mx0,
      not_tmp_5);
  assign crc_mux_193_nl = MUX_s_1_2_2((~ crc_19_5_lpi_2_dfm_mx0), crc_19_5_lpi_2_dfm_mx0,
      not_tmp_3);
  assign for_mux_2_nl = MUX_v_8_2_2((~ in_rsci_idat_mxwt), for_i_sva, fsm_output[2]);
  assign nl_z_out = conv_s2u_8_9(for_mux_2_nl) + 9'b000000001;
  assign z_out = nl_z_out[8:0];

  function automatic  MUX_s_1_2_2;
    input  input_0;
    input  input_1;
    input  sel;
    reg  result;
  begin
    case (sel)
      1'b0 : begin
        result = input_0;
      end
      default : begin
        result = input_1;
      end
    endcase
    MUX_s_1_2_2 = result;
  end
  endfunction


  function automatic [7:0] MUX_v_8_2_2;
    input [7:0] input_0;
    input [7:0] input_1;
    input  sel;
    reg [7:0] result;
  begin
    case (sel)
      1'b0 : begin
        result = input_0;
      end
      default : begin
        result = input_1;
      end
    endcase
    MUX_v_8_2_2 = result;
  end
  endfunction


  function automatic [0:0] readslicef_9_1_8;
    input [8:0] vector;
    reg [8:0] tmp;
  begin
    tmp = vector >> 8;
    readslicef_9_1_8 = tmp[0:0];
  end
  endfunction


  function automatic [8:0] conv_s2u_8_9 ;
    input [7:0]  vector ;
  begin
    conv_s2u_8_9 = {vector[7], vector};
  end
  endfunction

endmodule

// ------------------------------------------------------------------
//  Design Unit:    crc32
// ------------------------------------------------------------------


module crc32 (
  clk, rst, in_rsc_dat, in_rsc_vld, in_rsc_rdy, out_rsc_dat, out_rsc_vld, out_rsc_rdy
);
  input clk;
  input rst;
  input [7:0] in_rsc_dat;
  input in_rsc_vld;
  output in_rsc_rdy;
  output [31:0] out_rsc_dat;
  output out_rsc_vld;
  input out_rsc_rdy;



  // Interconnect Declarations for Component Instantiations 
  crc32_core crc32_core_inst (
      .clk(clk),
      .rst(rst),
      .in_rsc_dat(in_rsc_dat),
      .in_rsc_vld(in_rsc_vld),
      .in_rsc_rdy(in_rsc_rdy),
      .out_rsc_dat(out_rsc_dat),
      .out_rsc_vld(out_rsc_vld),
      .out_rsc_rdy(out_rsc_rdy)
    );
endmodule




`line 8 "tapeout/SPI_TapeOutBlockVRTL.v" 0

module tapeout_SPI_TapeOutBlockVRTL
#(
    parameter nbits = 32, // the size of the val/rdy msg for the SPI Minion (includes the two flow control bits)
    parameter num_entries = 5
)(
    input  logic clk,
    input  logic reset,

    input  logic loopthrough_sel,
    output logic minion_parity,
    output logic adapter_parity,

    // SPI Minion Ifc
    input  logic spi_min_sclk,
    input  logic spi_min_cs,
    input  logic spi_min_mosi,
    output logic spi_min_miso
);

//===============================================================================================
// TAPEOUT TASK: Create logics here to connect your module to the Send/Recv Ifc of the SPI stack
//===============================================================================================

logic         in_rsc_vld;
logic [31:0]  in_rsc_dat;
logic         in_rsc_rdy;

logic         out_rsc_vld;
logic [31:0]  out_rsc_dat;
logic         out_rsc_rdy;

logic [7:0]   truncated_in_rsc_dat;
assign truncated_in_rsc_dat = in_rsc_dat[7:0];

// We add two to nbits for the two SPI minion flow control bits 
SPI_v3_components_SPIstackVRTL #(nbits, num_entries) SPIstack
(
    .clk(clk),
    .reset(reset),
    .loopthrough_sel(loopthrough_sel),
    .minion_parity(minion_parity),
    .adapter_parity(adapter_parity),

    // SPI Minion Ifc
    .sclk(spi_min_sclk),
    .cs(spi_min_cs),
    .mosi(spi_min_mosi),
    .miso(spi_min_miso),

    // Send/Recv Ifc
    .recv_val(out_rsc_vld), 
    .recv_msg(out_rsc_dat), 
    .recv_rdy(out_rsc_rdy),

    .send_val(in_rsc_vld),
    .send_msg(in_rsc_dat),
    .send_rdy(in_rsc_rdy)
);

//=============================================================================
// TAPEOUT TASK: Instantiate your module below and connect it to the SPI stack
//=============================================================================

crc32 crc32_inst
(
  .clk(clk),
  .rst(reset),

  .in_rsc_dat(truncated_in_rsc_dat),
  .in_rsc_vld(in_rsc_vld),
  .in_rsc_rdy(in_rsc_rdy),

  .out_rsc_dat(out_rsc_dat),
  .out_rsc_vld(out_rsc_vld),
  .out_rsc_rdy(out_rsc_rdy)
);

endmodule

`endif /* SPI_TAPEOUTBLOCKVRTL */
//-----------------------------------------------------------
// Wrapper of placeholder SPI_TapeOutBlockVRTL__nbits_32__num_entries_5
//-----------------------------------------------------------

`ifndef SPI_TAPEOUTBLOCKVRTL__NBITS_32__NUM_ENTRIES_5
`define SPI_TAPEOUTBLOCKVRTL__NBITS_32__NUM_ENTRIES_5

module grp_15_SPI_TapeOutBlockRTL_32bits_5entries
(
  `ifdef USE_POWER_PINS
  inout vccd1, // User area 1 1.8V supply
  inout vssd1, // User area 1 digital ground
  `endif
  output logic [1-1:0] adapter_parity ,
  input logic [1-1:0] clk ,
  input logic [1-1:0] loopthrough_sel ,
  output logic [1-1:0] minion_parity ,
  input logic [1-1:0] reset ,
  input logic [1-1:0] spi_min_cs ,
  output logic [1-1:0] spi_min_miso ,
  input logic [1-1:0] spi_min_mosi ,
  input logic [1-1:0] spi_min_sclk 
);
  tapeout_SPI_TapeOutBlockVRTL
  #(
    .nbits( 34 ),
    .num_entries( 5 )
  ) v
  (
    .adapter_parity( adapter_parity ),
    .clk( clk ),
    .loopthrough_sel( loopthrough_sel ),
    .minion_parity( minion_parity ),
    .reset( reset ),
    .spi_min_cs( spi_min_cs ),
    .spi_min_miso( spi_min_miso ),
    .spi_min_mosi( spi_min_mosi ),
    .spi_min_sclk( spi_min_sclk )
  );
endmodule

`endif /* SPI_TAPEOUTBLOCKVRTL__NBITS_32__NUM_ENTRIES_5 */

